<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CPP实用编程中的一些小技巧和注意事项</title>
    <link href="/2023/12/28/some-tricks-of-CPP/"/>
    <url>/2023/12/28/some-tricks-of-CPP/</url>
    
    <content type="html"><![CDATA[<h2 id="c-中的窄化转换类型"><a href="#c-中的窄化转换类型" class="headerlink" title="c++中的窄化转换类型"></a>c++中的窄化转换类型</h2><ul><li>从浮点类型到整型。</li><li>从浮点类型到更窄或排名更低的浮点类型，除非要转换的值是 constexpr 并且在目标类型的范围内（即使目标类型不具有存储浮点类型的所有有效数字的精度）数字）。</li><li>从整型到浮点类型，除非要转换的值是 constexpr 并且其值可以准确地存储在目标类型中。</li><li>从一个整型到另一个不能表示原始类型的所有值的整型，除非要转换的值是 constexpr 并且其值可以准确地存储在目标类型中。这涵盖了从宽到窄的整数转换，以及整数符号转换（有符号到无符号，反之亦然）。</li></ul><h2 id="c-哪些地方禁止了窄化转换"><a href="#c-哪些地方禁止了窄化转换" class="headerlink" title="c++哪些地方禁止了窄化转换"></a>c++哪些地方禁止了窄化转换</h2><ul><li>列表初始化不允许大括号表达式中值的类型被窄化成需要构造的对象类型</li><li>被转换的常量表达式(<em>converted const expression</em>) <ul><li>比如定义数组时数组的长度，一般为<em>size_t &#x2F; unsigned long long</em>类型的常量表达式</li></ul></li></ul><h2 id="decltype-和-auto的妙用"><a href="#decltype-和-auto的妙用" class="headerlink" title="decltype 和 auto的妙用"></a>decltype 和 auto的妙用</h2><ul><li>单auto会失去对原变量的cv限定和引用，使用*decltype(auto) &#x2F; auto&amp;&amp;*可以达到目的</li></ul><h2 id="列表初始化中的聚合初始化"><a href="#列表初始化中的聚合初始化" class="headerlink" title="列表初始化中的聚合初始化"></a>列表初始化中的聚合初始化</h2><p>聚合体的要求</p><ol><li>数组</li><li>不能出现以下情况的类类型(c++17标准)<ul><li>派生类中含有<strong>继承构造函数</strong>，<em>explicit</em>声明的构造函数</li><li>派生类含有虚基类</li><li>类中含有非<em>private&#x2F;protected</em>的非静态数据成员</li><li>类中含有虚函数成员</li></ul></li></ol><h2 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h2><p>考虑以下情景，基类定义了若干构造函数分别针对进行若干成员进行初始化，派生类中只有一个成员需要定义，但<strong>它却需要重载若干构造函数来调用不同的基类构造函数</strong>，这样会造成代码冗余，并且编写起来会让人恼火，为了解决上述情况，我们可以使用using base::base来一次性引入基类的所有构造函数，当用子句初始化派生类对象时，可以达到直接调用基类构造函数的效果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">base</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">base</span>() : <span class="hljs-built_in">a1</span>(<span class="hljs-number">2</span>)&#123;&#125;;<br>    <span class="hljs-comment">// base(int a): a1(a)&#123;&#125;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a1;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">derived</span>:<span class="hljs-keyword">public</span> base&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/*inherited constructors 指的是</span><br><span class="hljs-comment">    如果 using 声明指代了正在定义的类的某个直接基类的构造函数（例如 using Base::Base;），</span><br><span class="hljs-comment">    那么在初始化派生类时，该基类的所有构造函数（忽略成员访问）均对重载决议可见。</span><br><span class="hljs-comment">    虽然标准规定忽略对基类的成员访问，但是继承构造函数必须在派生类中可访问，这样在初始化派生类时，首先调用基类的构造函数，派生类中的各成员</span><br><span class="hljs-comment">    使用默认成员初始化器(如果有的话)进行默认初始化*/</span><br>    <span class="hljs-keyword">using</span> base::base;<br>    <span class="hljs-comment">/*如果子类定义了相同签名的构造函数(若未定义，则在继承构造函数的影响下同签名构造函数默认是删除的)，则基类的同签名继承构造函数被隐藏*/</span><br>    <span class="hljs-built_in">derived</span>(<span class="hljs-type">int</span> a1):<span class="hljs-built_in">a2</span>(a1)&#123;&#125;<br>    <span class="hljs-comment">// derived(): a2(5)&#123;&#125;</span><br>    <span class="hljs-type">int</span> a2;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><h3 id="内存对齐的好处："><a href="#内存对齐的好处：" class="headerlink" title="内存对齐的好处："></a>内存对齐的好处：</h3><ul><li>cpu运算时首先通过数据总线取得数据，若数据没有按照线路位宽对齐，则可能需要增加取数的次数</li><li>dma访问硬盘时，要求数据是4k对齐的</li></ul><h3 id="gcc对于内存对齐的扩展支持-attribute-属性说明符"><a href="#gcc对于内存对齐的扩展支持-attribute-属性说明符" class="headerlink" title="gcc对于内存对齐的扩展支持 - __attribute__属性说明符"></a>gcc对于内存对齐的扩展支持 - __attribute__属性说明符</h3><ul><li><strong>attribute</strong>((aligned(long long)))设置变量的对齐长度为long long的对齐长度<blockquote><p>属性说明符指在为类型、对象、代码等引入由实现定义的属性，在gcc中属性说明符的语法一般为<code>__atribute__(())</code>，c++11引入了属性说明符序列，语法为<code>[[attr]] [[attr1, attr2, attr3(args)]] [[namespace::attr(args)]] alignas-说明符 </code>, 两种属性语法都可以位于声明的对象之后或者位于整个声明序列之前，这些情况下它们被组合起来。大多数其他情形中，属性应用于直接位于其之前的实体(或声明序列中对应的实体)。</p><p><code>class-key attr(optional) class-head-name</code><br>对于类来说，在class后直接加入属性视为是对整个类加上属性，对于函数来说，在函数名后加入属性视为对该函数实体加上属性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">&gt;<span class="hljs-type">void</span> h [[noreturn]] () <span class="hljs-comment">//OK</span><br>&gt;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">q</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> [[noreturn]] <span class="hljs-comment">//error, 这里的属性描述符相当于给函数类型</span></span><br></code></pre></td></tr></table></figure></blockquote></li></ul><h3 id="c-11新特性alignas-alignof-关键字"><a href="#c-11新特性alignas-alignof-关键字" class="headerlink" title="c++11新特性alignas alignof 关键字"></a>c++11新特性alignas alignof 关键字</h3><ul><li>c++11之前，gcc可以通过__alignof__(int) 获得对齐长度；<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">short</span> r1 = <span class="hljs-number">4</span>;<br>__attribute__((<span class="hljs-built_in">aligned</span>(<span class="hljs-number">8</span>))) <span class="hljs-type">short</span> r2 = <span class="hljs-number">4</span>;<br>std::cout&lt;&lt;__alignof__(r2)&lt;&lt;std::endl;<br></code></pre></td></tr></table></figure></li><li>c++11引入alignof关键字获取<strong>类型</strong>的对齐长度，不能获取变量的对其长度<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> x1 = <span class="hljs-built_in">alignof</span>(<span class="hljs-type">int</span>);<br><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// auto x2 = alignof(a); error</span><br></code></pre></td></tr></table></figure></li><li>c++11引入alignas设置对齐长度，可用在结构体前设置整个结构体的对齐长度，设置的对齐长度必须大于成员自定义或默认的对齐长度，否则设置无效</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">alignas</span>(<span class="hljs-number">4</span>) X&#123; <span class="hljs-comment">//alignas(4)无效</span><br>    <span class="hljs-built_in">alignas</span>(<span class="hljs-type">double</span>) <span class="hljs-type">int</span> x3;<br>    <span class="hljs-built_in">alignas</span>(<span class="hljs-number">8</span>) <span class="hljs-type">char</span> x4;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="function-wrappers"><a href="#function-wrappers" class="headerlink" title="function wrappers"></a>function wrappers</h3><p>std::function&lt;F(Args…)&gt; 是一种类型擦除对象。这意味着它擦除了某些操作发生的细节，并为它们提供了统一的运行时接口。对于std::function，主要的操作包括复制&#x2F;移动、销毁和通过operator()进行“调用”——即“类似函数的调用运算符”。可以包装lambdas，std::bind, 函数指针 &amp; 仿函数</p><blockquote><p>lambdas的复制和默认构造函数是删除的</p></blockquote><h3 id="reference-wrappers"><a href="#reference-wrappers" class="headerlink" title="reference wrappers"></a>reference wrappers</h3><p>std::ref(val) 返回对于一个val的reference wrapper<br>std::cref(val) 返回一个对于常量val的reference wrapper</p><h3 id="remove-if-find-if"><a href="#remove-if-find-if" class="headerlink" title="remove_if &amp; find_if"></a>remove_if &amp; find_if</h3><p>find_if(ForwardIt first, ForwardIt last, UnaryPredicate p)找到一个满足p的迭代器first并返回<br>remove_if(ForwardIt first, ForwardIt last, UnaryPredicate p)返回全部满足条件p的迭代器的后一个位置，实则就是将满足条件的元素全部移动至容器前方，将不满足的全部移至后方，可搭配erase方法使用:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::string str2 = <span class="hljs-string">&quot;Text\n with\tsome \t  whitespaces\n\n&quot;</span>;<br>    str2.<span class="hljs-built_in">erase</span>(std::<span class="hljs-built_in">remove_if</span>(str2.<span class="hljs-built_in">begin</span>(),<br>                              str2.<span class="hljs-built_in">end</span>(),<br>                              [](<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> x)&#123;<span class="hljs-keyword">return</span> std::<span class="hljs-built_in">isspace</span>(x);&#125;),<br>               str2.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure><h3 id="c-17中新引入的推导指引decution-guide"><a href="#c-17中新引入的推导指引decution-guide" class="headerlink" title="c++17中新引入的推导指引decution guide"></a>c++17中新引入的推导指引decution guide</h3><p>推导指引就是可以省略显式指出类模板的模板实参，交给编译器去做推导<br>手动实现一个类模板的推导指引规则的语法为<br><code>explicit-specifier (optional) template-name ( parameter-declaration-clause ) -&gt; simple-template-id </code><br>标准库的各大容器都实现了相应的推导指引规则<br>priority_queue对应的推导指引规则之一:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> Comp, <span class="hljs-keyword">class</span> Container &gt;</span><br><span class="hljs-function"><span class="hljs-title">priority_queue</span><span class="hljs-params">( Comp, Container )</span></span><br><span class="hljs-function">    -&gt; priority_queue&lt;<span class="hljs-keyword">typename</span> Container::value_type, Container, Comp&gt;</span>;<br></code></pre></td></tr></table></figure><p>这样我们只需在实例化priority_queue时给出Comp和Container这两个实参就够了，具体例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">priority_queue<br>        <span class="hljs-comment">// &lt;ListNode*, vector&lt;ListNode*&gt;, function&lt;bool(ListNode*, ListNode*)&gt;&gt;可省略</span><br>        pq&#123;[](<span class="hljs-keyword">auto</span>&amp; a, <span class="hljs-keyword">auto</span>&amp; b)-&gt;<span class="hljs-type">bool</span>&#123;<span class="hljs-keyword">return</span> a-&gt;val &gt; b-&gt;val;&#125;, lists&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>webserver-log模块</title>
    <link href="/2023/12/10/webserver-log/"/>
    <url>/2023/12/10/webserver-log/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>精度输出</title>
    <link href="/2023/12/07/%E7%B2%BE%E5%BA%A6%E8%BE%93%E5%87%BA/"/>
    <url>/2023/12/07/%E7%B2%BE%E5%BA%A6%E8%BE%93%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<p>在默认的浮点表示法中，精度字段指定小数点前后显示的有意义数字的最大数量</p><h2 id="std-fixed"><a href="#std-fixed" class="headerlink" title="std::fixed"></a>std::fixed</h2><p>std::fixed – 固定浮点表示法：它以定点表示法写入浮点值。该值的小数部分位数与精度字段（精度）指定的位数完全相同，并且没有指数部分。设置后如果不切换为其他模式，如std::senticific(它以科学点表示法写入浮点值。该值始终仅用小数点前一位数字表示，后跟小数点和与精度字段 (精度) 一样多的小数位数。最后，该表示法始终包含由字母“ e ”组成的指数部分，后跟可选符号和三个指数数字。)<br><code>double a = 4.342434245</code><br><code>std::cout&lt;&lt;std::fixed&lt;&lt;a</code><br>输出结果： 4.342424 （精度默认为6）</p><h2 id="std-set-precision"><a href="#std-set-precision" class="headerlink" title="std::set_precision()"></a>std::set_precision()</h2><p>设置输出精度字段，设置一次即可，最大可设置为19</p><p><code>constexpr long double pi&#123;std::numbers::pi_v&lt;long double&gt;&#125;;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">p</span>(<span class="hljs-number">0</span>); p &lt;= max_precision; ++p)<br>       std::cout &lt;&lt; std::<span class="hljs-built_in">setw</span>(<span class="hljs-number">2</span>) &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt;       std::<span class="hljs-built_in">setprecision</span>(p) &lt;&lt; pi &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure><p>输出结果：<br>precision: pi:<br> 0  3<br> 1  3<br> 2  3.1<br> 3  3.14<br> 4  3.142<br> 5  3.1416<br> 6  3.14159<br> 7  3.141593<br> 8  3.1415927<br> 9  3.14159265<br>10  3.141592654  </p><h2 id="std-setw"><a href="#std-setw" class="headerlink" title="std::setw()"></a>std::setw()</h2><p>更改且只更改<strong>下一个</strong>输入&#x2F;输出字段的宽度。当在表达式 out &lt;&lt; setw(n) 或 in &gt;&gt; setw(n) 中使用时，将流 out 或 in 的宽度参数精确设置为 n</p><p>应用到输出流</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::cout &lt;&lt; <span class="hljs-string">&quot;没有 setw：[&quot;</span> &lt;&lt; <span class="hljs-number">42</span> &lt;&lt; <span class="hljs-string">&quot;]\n&quot;</span><br>&lt;&lt; <span class="hljs-string">&quot;setw(6)：[&quot;</span> &lt;&lt; std::<span class="hljs-built_in">setw</span>(<span class="hljs-number">6</span>) &lt;&lt; <span class="hljs-number">42</span> &lt;&lt; <span class="hljs-string">&quot;]\n&quot;</span><br>&lt;&lt; <span class="hljs-string">&quot;setw(6)，并输出多个元素：[&quot;</span> &lt;&lt; <span class="hljs-number">89</span> &lt;&lt; std::<span class="hljs-built_in">setw</span>(<span class="hljs-number">6</span>) &lt;&lt; <span class="hljs-number">12</span> &lt;&lt; <span class="hljs-number">34</span> &lt;&lt; <span class="hljs-string">&quot;]\n&quot;</span>;<br><br></code></pre></td></tr></table></figure><p>输出结果：<br>没有 setw：[42]<br>setw(6)：[    42]<br>setw(6)，并输出多个元素：[89    1234]  </p><p>应用到输入流</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::istringstream <span class="hljs-title">is</span><span class="hljs-params">(<span class="hljs-string">&quot;hello, world&quot;</span>)</span></span>;<br><span class="hljs-type">char</span> arr[<span class="hljs-number">10</span>];<br>is &gt;&gt; std::<span class="hljs-built_in">setw</span>(<span class="hljs-number">6</span>) &gt;&gt; arr;<br></code></pre></td></tr></table></figure><p>arr &#x3D; “hello\0”</p><h2 id="std-left"><a href="#std-left" class="headerlink" title="std::left"></a>std::left</h2><p>设置字符输出为左对齐</p><h2 id="std-setfill-char-c"><a href="#std-setfill-char-c" class="headerlink" title="std::setfill(char c)"></a>std::setfill(char c)</h2><p>设置当字符串输出宽度达不到setw的值时的填充字符c</p><h2 id="组合以上方法的实例"><a href="#组合以上方法的实例" class="headerlink" title="组合以上方法的实例"></a>组合以上方法的实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">9</span>) &lt;&lt; std::left;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> size&#123;<span class="hljs-number">1ull</span>&#125;; size &lt; <span class="hljs-number">10&#x27;00&#x27;00&#x27;00&#x27;00ull</span>; size *= <span class="hljs-number">100</span>)<br>   &#123;<br>       <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> start = std::chrono::steady_clock::<span class="hljs-built_in">now</span>();<br>       <span class="hljs-built_in">do_some_work</span>(size);<br>       <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> end = std::chrono::steady_clock::<span class="hljs-built_in">now</span>();<br><br>       <span class="hljs-type">const</span> std::chrono::duration&lt;<span class="hljs-type">double</span>&gt; diff = end - start;<br><br>       std::cout &lt;&lt; <span class="hljs-string">&quot;用于填充并迭代 &quot;</span> &lt;&lt; std::<span class="hljs-built_in">setw</span>(<span class="hljs-number">9</span>)<br>                 &lt;&lt; size &lt;&lt; <span class="hljs-string">&quot; 个 int 的 vector 需要 : &quot;</span> &lt;&lt; diff &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p>输出结果:</p><p>用于填充并迭代 1         个 int 的 vector 需要 : 0.000006568s<br>用于填充并迭代 100       个 int 的 vector 需要 : 0.000002854s<br>用于填充并迭代 10000     个 int 的 vector 需要 : 0.000116290s<br>用于填充并迭代 1000000   个 int 的 vector 需要 : 0.011742752s<br>用于填充并迭代 100000000 个 int 的 vector 需要 : 0.505534949s</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>chrono用法</title>
    <link href="/2023/12/05/chrono%E7%94%A8%E6%B3%95/"/>
    <url>/2023/12/05/chrono%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="chrono库的"><a href="#chrono库的" class="headerlink" title="chrono库的"></a>chrono库的</h2><p>chrono 库定义三种主要类型以及工具函数和常用 typedef</p><ul><li>时钟(clock)<ul><li>system_clock </li><li>steady_clock<br>C++ 标准不提供有关时钟精度、起始点或有效时间范围的保证。通常， std::chrono:system_clock的起点是 1.1.1970，即所谓的UNIX-epoch。对于std::chrono::steady_clock，通常是 PC 的启动时间。</li><li>每种clock都有类似的成员函数：<ul><li>rep</li><li>period</li><li>std::chrono::duration&lt;rep, period&gt;(见后文)</li><li>std::chrono::timepoint<system_clock>(见后文)</li></ul></li><li>使用now方法可以获得当前的timepoint</li></ul></li><li>时间点(timepoint)<ul><li>类模板原型：<code>template &lt;class Clock, class Duration = typename Clock::duration&gt;  class time_point;</code>  </li><li>表示时间中的一个点。它被实现成如同存储一个 Duration 类型的值，指定自 Clock 的纪元起始开始的时间间隔。</li><li>使用timepoint的time_since_epoch方法获得离epoch的duration，或者对两个不同的time_point进行加减操作也可以获取duration(当然，也可以获得一个新的timepoint)，<strong>但不能通过直接输出timepoint来获取duration</strong></li></ul></li><li>时长(duration)<ul><li><code>template&lt;class rep, class Period = ratio&lt;1&gt; &gt;   class duration</code><br>Rep  表示一种数值类型，用来表示Period的数量，比如int float double<br>Period是ratio类型，用来表示【用秒表示的时间单位】比如second,milisecond<br><code>template &lt;intmax_t N, intmax_t D = 1&gt;  class ratio;</code><br>N代表分子，D代表分母，所以ratio表示一个分数值。<br><strong>若 Rep 是浮点类型，则 duration 能表示小数的计次数</strong>  </li><li>有些duration类型可以简写，比如<code>std::chrono::milliseconds = std::chrono::duration&lt;/* int45 */, std::milli&gt;</code></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//一个时间点的类型定义（语法见条款9）</span><br><span class="hljs-keyword">using</span> Time = std::chrono::steady_clock::time_point;<br><br><span class="hljs-comment">//“enum class”见条款10</span><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Sound</span> &#123; Beep, Siren, Whistle &#125;;<br><br><span class="hljs-comment">//时间段的类型定义</span><br><span class="hljs-keyword">using</span> Duration = std::chrono::steady_clock::duration;<br><br><span class="hljs-comment">//在时间t，使用s声音响铃时长d</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setAlarm</span><span class="hljs-params">(Time t, Sound s, Duration d)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>我们在使用chrono库中的小时，分钟，秒等时间单位时，需要创建如<code>hours(1)</code>, <code>seconds(30)</code>来表示时间长度，可以加入<code>using namespace literals</code>或<code>using namespace chrono_literals</code>以使用标准后缀如秒（s），毫秒（ms）和小时（h）等简化在C++14中的代码，其中标准后缀基于C++11对用户自定义常量的支持。这些后缀在std::literals命名空间中实现，因此上述代码可以按照以下方式重写：1h, 30s</li></ul><blockquote><p>literals标准后缀规定了string和chrono::duration的各种后缀，二者有相同后缀名s，在string中”abcd\0111”s表示使用类型为const char *的”abcd\0111”来构建字符串并且忽略\0作为结束符，同样的，我们可以引入<code>using namespace string_literals</code>来使用s后缀</p></blockquote><h2 id="chrono一些特性"><a href="#chrono一些特性" class="headerlink" title="chrono一些特性"></a>chrono一些特性</h2><ol><li>system_clock  :: to_time_t(time_point&amp; t)将time_point 转换为 time_t 类型：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> <span class="hljs-type">const</span> now = std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br> std::<span class="hljs-type">time_t</span> newt = std::chrono::system_clock::<span class="hljs-built_in">to_time_t</span>(now);<br></code></pre></td></tr></table></figure><blockquote><p>c++11前获取当前时间 std::time_t oldt &#x3D; std::time({});</p></blockquote></li></ol><h2 id="chrono注意事项"><a href="#chrono注意事项" class="headerlink" title="chrono注意事项"></a>chrono注意事项</h2><ol><li>由于各种duration表示不同，chrono库提供了duration_cast类型转换函数。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 无精度损失的整数尺度转换：无转型</span><br>   std::cout &lt;&lt; std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">1</span>s).<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot; 毫秒\n&quot;</span><br>             &lt;&lt; std::chrono::<span class="hljs-built_in">microseconds</span>(<span class="hljs-number">1</span>s).<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot; 微秒\n&quot;</span><br>             &lt;&lt; std::chrono::<span class="hljs-built_in">nanoseconds</span>(<span class="hljs-number">1</span>s).<span class="hljs-built_in">count</span>()  &lt;&lt; <span class="hljs-string">&quot; 纳秒\n&quot;</span>;<br><br>   <span class="hljs-comment">// 有精度损失的整数尺度转换：需要转型</span><br>   std::cout &lt;&lt; std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::minutes&gt;(<span class="hljs-number">1</span>s).<span class="hljs-built_in">count</span>()<br>             &lt;&lt; <span class="hljs-string">&quot; 分\n&quot;</span>;<br>   <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> t1 = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>   <span class="hljs-built_in">f</span>();<br>   <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> t2 = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>   <span class="hljs-comment">// 浮点时长不需要转型</span><br>   <span class="hljs-type">const</span> std::chrono::duration&lt;<span class="hljs-type">double</span>, std::milli&gt; fp_ms = t2 - t1;<br>   <span class="hljs-comment">// 浮点转整数需要转型</span><br>   <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> int_ms = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(t2 - t1);<br></code></pre></td></tr></table></figure></li><li>system_clock 和 steady_clock对应的duration的period都是纳秒, 也就是10的负9次方，当二者使用now获得的timepoint进行操作时，比如二者相减获取相差时间，输出的duration的单位即为period所对应的单位，比如period为std::micro &#x2F; std::ratio&lt;1, 1000000&gt;, 则会输出xxx ms，<strong>使用duration的count方法会直接输出xxx，没有单位</strong></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>字符串处理</title>
    <link href="/2023/12/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    <url>/2023/12/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="判断字符是数字还是字母"><a href="#判断字符是数字还是字母" class="headerlink" title="判断字符是数字还是字母"></a>判断字符是数字还是字母</h2><ul><li>isdigit(char c) : isdigit(int)的重载版本</li><li>isalpha(char c)</li><li>tolower&#x2F;toupper</li></ul><h2 id="string-view"><a href="#string-view" class="headerlink" title="string_view"></a>string_view</h2>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
      <category>cpp-related</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>链表总结</title>
    <link href="/2023/12/01/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/"/>
    <url>/2023/12/01/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><h2 id="合并链表"><a href="#合并链表" class="headerlink" title="合并链表"></a>合并链表</h2><h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><ul><li>在结尾时返回递归结果，这样当前递归栈帧可以被自己调用的下一层递归函数栈帧覆盖</li><li>合并链表时从头开始反转并在递归时将当前指针前一个指针(也就是下一个要被反转的指针)作为参数可以实现尾递归，类似于合并链表的双指针解法</li></ul>]]></content>
    
    
    <categories>
      
      <category>cpp related</category>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>list</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数位DP</title>
    <link href="/2023/12/01/%E6%95%B0%E4%BD%8DDP/"/>
    <url>/2023/12/01/%E6%95%B0%E4%BD%8DDP/</url>
    
    <content type="html"><![CDATA[<h3 id="数位DP是什么？"><a href="#数位DP是什么？" class="headerlink" title="数位DP是什么？"></a>数位DP是什么？</h3><p>数位是指把一个数字按照个、十、百、千等等一位一位地拆开，关注它每一位上的数字。如果拆的是十进制数，那么每一位数字都是 0~9，其他进制可类比十进制。</p><p>数位 DP：用来解决一类特定问题，这种问题比较好辨认，一般具有这几个特征：</p><ol><li><p>要求统计满足一定条件的数的数量（即，最终目的为计数）；</p></li><li><p>这些条件经过转化后可以使用「数位」的思想去理解和判断；</p></li><li><p>输入会提供一个数字区间（有时也只提供上界）来作为统计的限制；</p></li><li><p>上界很大（比如 10^{18}），暴力枚举验证会超时。</p></li></ol><p>数位 DP 的基本原理：</p><p>考虑人类计数的方式，最朴素的计数就是从小到大开始依次加一。但我们发现对于位数比较多的数，这样的过程中有许多重复的部分。例如，从 7000 数到 7999、从 8000 数到 8999、和从 9000 数到 9999 的过程非常相似，它们都是后三位从 000 变到 999，不一样的地方只有千位这一位，所以我们可以把这些过程归并起来，将这些过程中产生的计数答案也都存在一个通用的数组里。此数组根据题目具体要求设置状态，用递推或 DP 的方式进行状态转移。<br>数位 DP 中通常会利用常规计数问题技巧，比如把一个区间内的答案拆成两部分相减，比如求某个区间[x-y]中满足某个条件的数的个数，可以使用dp[y]-dp[x]来得出答案<br>那么有了通用答案数组，接下来就是统计答案。统计答案可以选择<strong>记忆化搜索</strong>，也可以选择<strong>循环迭代递推</strong>。为了不重不漏地统计所有不超过上限的答案，要从高到低枚举每一位，再考虑每一位都可以填哪些数字，最后利用通用答案数组统计答案。</p><ul><li>以上内容摘自OI-WIKI中关于<a href="https://oi-wiki.org/dp/number/">数位DP</a>的介绍</li></ul><h3 id="数位DP的普遍做法"><a href="#数位DP的普遍做法" class="headerlink" title="数位DP的普遍做法"></a>数位DP的普遍做法</h3><p>数位DP通常要求将区间最大值N拆为B进制的各个位(以10进制为例)， 假设N在10进制下有n位，则N可以用下式表示：<br><img src="/2023/12/01/%E6%95%B0%E4%BD%8DDP/n%E7%9A%84%E8%A1%A8%E7%A4%BA.jpg"><br>从最高位开始，由于所在区间挑选的所有数不能大于N，则对于每个位来说，可选的数为0-a[i]-1 和 a[i]两种情况(根据特定题目，可选的数还会进一步缩小)， 若当前位选择0-a[i]-1，则之后的各个位可以随心所欲的挑选符合题意的数，若当前位选择a[i]，则后一位也必须分成两种情况来讨论，DP的过程可以用二叉树来进行模拟<br><img src="/2023/12/01/%E6%95%B0%E4%BD%8DDP/y%E6%80%BB.jpg"><br>左边的分支即为挑选比当前位小的数，最右边的分支表示选择的数即为原数，左边分支由于后续不再受到N的限制，可以直接用组合数或者动态规划的方式求得所有情况，于是不必要继续分支下去，最右边的分支表示1种情况，并且最后需判断原数是否满足题意即可</p><p>介绍一道例题，来自力扣：<a href="https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/">902.最大为N的数字组合</a><br>根据评论区star靠前的各个题解，我总结出了三种解法：</p><ol><li>最接近所述数位DP原理和普遍做法的题解</li></ol><blockquote><p>对 x 进行「从高到低」的处理（假定 x 数位为 nnn），对于第 k 位而言（k 不为最高位），假设在 x 中第 k 位为 cur，那么为了满足「大小限制」关系，我们只能在 [1,cur−1] 范围内取数，同时为了满足「数字只能取自 nums」的限制，因此我们可以利用 nums 本身有序，对其进行二分，找到满足 nums[mid] &lt;&#x3D; cur 的最大下标 r，根据 nums[r] 与 cur 的关系进行分情况讨论：</p><ul><li>nums[r] &#x3D; cur: 此时位置 k 共有 r 种选择，而后面的每个位置由于 nums[i] 可以使用多次，每个位置都有 m 种选择，共有 n-p 个位置，因此该分支往后共有 <strong>r*m的n-p次方</strong> 种合法方案。且由于 nums[r] &#x3D; cur，往后还有分支可决策（需要统计），因此需要继续处理；</li><li>nums[r]&lt;cur：此时算上 nums[r]，位置 k 共有 r+1 种选择，而后面的每个位置由于 nums[i] 可以使用多次，每个位置都有 m 种选择，共有 n−p 个位置，因此该分支共有 **(r+1)<em>m的n-p次方</em>* 种合法方案，由于 nums[r]&lt;cur，往后的方案数（均满足小于关系）已经在这次被统计完成，累加后进行 break；</li><li>nums[r]&gt;cur：该分支往后不再满足「大小限制」要求，合法方案数为 0，直接 break。<br>其他细节：实际上，我们可以将 res1 和 res2 两种情况进行合并处理。</li></ul><footer><strong>宫水三叶,</strong><cite><a href="https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/solution/by-ac_oier-8k27/">数位DP+二分</a></cite></footer></blockquote><p>该实现的时间复杂度为O(log10 N)代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; nums;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        std::vector&lt;<span class="hljs-type">int</span>&gt; list;<br>        <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;<br>            list.<span class="hljs-built_in">push_back</span>(x % <span class="hljs-number">10</span>);<br>            x /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> n = list.<span class="hljs-built_in">size</span>(), m = nums.<span class="hljs-built_in">size</span>(), ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//p指的是目前遍历了几个位</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>, p = <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--, p++) &#123;<br>            <span class="hljs-type">int</span> cur = list[i];<br>            <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = m - <span class="hljs-number">1</span>;<br><br>            <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>                <span class="hljs-type">int</span> mid = (l + r + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">if</span> (nums[mid] &lt;= cur)<br>                    l = mid;<br>                <span class="hljs-keyword">else</span><br>                    r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (nums[r] &gt; cur) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[r] == cur) &#123;<br>                ans += r * <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(std::<span class="hljs-built_in">pow</span>(m, n - p));<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)<br>                    ans++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[r] &lt; cur) &#123;<br>                ans += (r + <span class="hljs-number">1</span>) * <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(std::<span class="hljs-built_in">pow</span>(m, n - p));<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 位数比x小的话，从1位数到n-1位数，每个位都可填m个数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, last = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> cur = last * m;<br>            ans += cur;<br>            last = cur;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">atMostNGivenDigitSet</span><span class="hljs-params">(std::vector&lt;std::string&gt;&amp; digits, <span class="hljs-type">int</span> max)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = digits.<span class="hljs-built_in">size</span>();<br>        nums.<span class="hljs-built_in">resize</span>(n);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>            nums[i] = std::<span class="hljs-built_in">stoi</span>(digits[i]);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dp</span>(max);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><ol start="2"><li>动态规划</li></ol><p>先看代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">atMostNGivenDigitSet</span><span class="hljs-params">(vector&lt;string&gt;&amp; digits, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        string s = <span class="hljs-built_in">to_string</span>(n);<br>        <span class="hljs-type">int</span> m = digits.<span class="hljs-built_in">size</span>(), k = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">/*dp数组表示前i位由digits中的数字构造并且前i位所表示的数字小于n的所有数数量*/</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(k + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-comment">/*last 表示前i-1是否为n的前i-1位，即是否为最大值， nlast表示当前位是否会出现n的第i位</span><br><span class="hljs-comment">        若出现且last为真，则进入最右分支，否则进入左子分支*/</span><br>        <span class="hljs-type">int</span> last = <span class="hljs-number">1</span>, nlast = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>                <span class="hljs-keyword">if</span> (digits[j][<span class="hljs-number">0</span>] == s[i<span class="hljs-number">-1</span>]) &#123;<br>                    nlast = last;<br>                    <span class="hljs-comment">// dp[i]++;</span><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (digits[j][<span class="hljs-number">0</span>] &lt; s[i<span class="hljs-number">-1</span>]) &#123;<br>                    <span class="hljs-comment">/*若last为假，则不需要考虑当前位要小于n的当前位的状况，之后会将其一并加入*/</span><br>                    dp[i] += last;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">/**/</span><br>                dp[i] += m + dp[i - <span class="hljs-number">1</span>] * m;<br>            &#125;<br>            <span class="hljs-comment">/*更新last并重置nlast*/</span><br>            last = nlast;<br>            nlast = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[k] + last; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>状态转移方程为：<br><code>dp[i]=m+dp[i−1]×m+last×C[i]</code><br>迭代过程中用last来记录是否还受到N的约束，m 就是 dp[i] 中单个字符所组成的数量，相当于 res3， C[i] 表示nums中小于N当前第i位的个数，这里其实相当于将第一种解法所述的 res1 和 res2 动态的在迭代过程中求出，dp[i-1] * m表示早就进入了左边的分支，但是并没有一并求出，last * C[i] 表示在此次迭代才进入了最右分支的左边分支， 最后的加last就是将最右边分支的一种情况加上  </p><ol start="3"><li>递归 + 记忆化搜索(最难理解的一个解法)<br>先看代码:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">atMostNGivenDigitSet</span><span class="hljs-params">(vector&lt;string&gt;&amp; digits, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> s = <span class="hljs-built_in">to_string</span>(n);<br>        <span class="hljs-type">int</span> m = s.<span class="hljs-built_in">length</span>(), dp[m];<br>        <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>         function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">bool</span>, <span class="hljs-type">bool</span>)&gt; f = [&amp;](<span class="hljs-type">int</span> i, <span class="hljs-type">bool</span> is_limit, <span class="hljs-type">bool</span> is_num) -&gt; <span class="hljs-type">int</span> &#123;<br>             <span class="hljs-keyword">if</span> (i == m) <span class="hljs-keyword">return</span> is_num;<br>             <span class="hljs-keyword">if</span>(!is_limit &amp;&amp; is_num &amp;&amp; dp[i] &gt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> dp[i];<br>             <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>             <span class="hljs-keyword">if</span> (!is_num) res = <span class="hljs-built_in">f</span>( i + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>             <span class="hljs-type">char</span> up = is_limit ? s[i] : <span class="hljs-string">&#x27;9&#x27;</span>;<br>             <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; d : digits) &#123;<br>                 <span class="hljs-keyword">if</span>( d[<span class="hljs-number">0</span>] &gt; up) <span class="hljs-keyword">break</span>;<br>                 res += <span class="hljs-built_in">f</span>(i + <span class="hljs-number">1</span>, is_limit &amp;&amp; d[<span class="hljs-number">0</span>] == up, <span class="hljs-literal">true</span>);<br>             &#125;<br>             <span class="hljs-keyword">if</span>(!is_limit &amp;&amp; is_num)dp[i] = res;<br>             <span class="hljs-keyword">return</span> res;<br>         &#125;;<br>         <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(<span class="hljs-number">0</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>); <br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>将 n 转换成字符串 s，定义 f(i,isLimit,isNum) 表示构造从左往右第 i 位及其之后数位的合法方案数，其中：</p><p>isLimit表示当前是否受到了 n 的约束。若为真，则第 i 位填入的数字至多为 s[i]，否则至多为 9。<br>isNum 表示 i 前面的数位是否填了数字。若为假，则当前位可以跳过（不填数字），或者要填入的数字至少为 1；若为真，则必须填数字，且要填入的数字从 0 开始。这样我们可以控制构造出的是一位数&#x2F;两位数&#x2F;三位数等等。对于本题而言，要填入的数字可直接从 digits 中选择。<br>枚举要填入的数字，具体实现逻辑见代码。</p><p>代码中 Java&#x2F;C++&#x2F;Go 只需要记忆化 i，因为：</p><p>对于一个固定的 i，它受到 isLimit 或 isNum 的约束在整个递归过程中至多会出现一次，没必要记忆化。<br>另外，如果只记忆化 iii，dp 数组的含义就变成在不受到 n 的约束时的合法方案数，所以要在 !isLimit &amp;&amp; isNum 成立时才去记忆化。</p><footer><strong>灵神</strong><cite><a href="https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/solutions/1900101/shu-wei-dp-tong-yong-mo-ban-xiang-xi-zhu-e5dg/">数位 DP 通用模板 + 详细注释 + 题单（Python/Java/C++/Go）</a></cite></footer></blockquote>]]></content>
    
    
    <categories>
      
      <category>cpp related</category>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lldb调试器调试多进程</title>
    <link href="/2023/11/28/lldb%E8%B0%83%E8%AF%95%E5%99%A8%E8%B0%83%E8%AF%95%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    <url>/2023/11/28/lldb%E8%B0%83%E8%AF%95%E5%99%A8%E8%B0%83%E8%AF%95%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="vscode-lldb-环境下的多进程调试"><a href="#vscode-lldb-环境下的多进程调试" class="headerlink" title="vscode&amp;lldb 环境下的多进程调试"></a>vscode&amp;lldb 环境下的多进程调试</h2><p>vscode目前不支持使用lldb作为调试器的c++项目的多进程调试，gdb可以在launch.json中修改setupcommand来达到调试所有进程的目的，但是lldb不行，即使修改setupcommand也不能在子进程中设置断点并调试  </p><p>vscode的codelldb插件支持command prompt命令可以在命令行中操作lldb，此时可以先设置lldb的fork属性以及进程断点，之后运行时自动切换至该子进程<br>目前测试一个进程只能绑定一个进程，若想绑定多进程可以在主进程运行之后使用ps命令查看子进程pid，之后打开多个终端运行lldb attach，<a href="https://stackoverflow.com/questions/14746315/how-to-attach-to-child-process-in-lldb">StackOverflow给出了另一种方法</a></p><h2 id="lldb命令"><a href="#lldb命令" class="headerlink" title="lldb命令"></a>lldb命令</h2><p>lldb基本用法：</p><ul><li>target create : 一般来说，若以launch操作启动lldb时会附加可执行文件名(也就是执行的目标target)，若没有指定，在进入lldb后可用该命令指定target<ul><li>调试可执行文件tinywebserver生成的core dump文件：<code>(lldb) target create &quot;/home/kuli/tinywebserver/TinyWebServer/build/tinywebserver&quot; --core &quot;/tmp/core.1579&quot;</code></li></ul></li><li>r : 执行target </li><li>c ：继续执行直至遇到下一个断点 </li><li>q ：退出lldb</li><li>bt : 展开断点所在函数的call stack</li><li>b file:123  : 设置file断点在123行</li><li>attach pid : 将lldb附着在已经在执行的一个进程上</li><li>process interrupt&#x2F;ctrl + c ：中断进程</li></ul><p>lldb的quit命令会杀死(process kill)调试的进程，和kill命令默认发送的sigterm信号不同</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>systemd/journald - archLinux下的系统服务管理</title>
    <link href="/2023/11/26/systemd/"/>
    <url>/2023/11/26/systemd/</url>
    
    <content type="html"><![CDATA[<h2 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h2><p>Systemd 是 Linux 系统工具，用来启动守护进程，已成为大多数发行版的标准配置。<br>systemd 是一个 Linux 系统基础组件的集合，提供了一个系统和服务管理器，运行为 PID 1 并负责启动其它程序。功能包括：支持并行化任务；同时采用 socket 式与 D-Bus 总线式启用服务；按需启动守护进程（daemon）；利用 Linux 的 cgroups 监视进程；支持快照和系统恢复；维护挂载点和自动挂载点；各服务间基于依赖关系进行精密控制。systemd 支持 SysV 和 LSB 初始脚本，可以替代 sysvinit。除此之外，功能还包括日志进程、控制基础系统配置，维护登陆用户列表以及系统账户、运行时目录和设置，可以运行容器和虚拟机，可以简单的管理网络配置、网络时间同步、日志转发和名称解析等。<br>在历史上，<strong>systemd中的“服务”（service）被称作守护进程（daemon）</strong>，它们在后台运行（即没有UI、不与终端交互），等待特定事件的发生并提供服务。<br>Systemd 可以管理所有系统资源。不同的资源统称为 Unit（单位）。<br>unit通常包括但不限于：服务（.service）、挂载点（.mount）、设备（.device）和套接字（.socket）。</p><h2 id="systemd-journald-systemd的日志管理"><a href="#systemd-journald-systemd的日志管理" class="headerlink" title="systemd-journald - systemd的日志管理"></a>systemd-journald - systemd的日志管理</h2><h3 id="breif-introduction"><a href="#breif-introduction" class="headerlink" title="breif introduction"></a>breif introduction</h3><p>systemd 提供了自己的日志系统（logging system），称为 journal。使用 systemd 日志，无需额外安装日志服务（syslog）。使用 <a href="https://man.archlinux.org/man/journalctl.1">journalctl(1)</a>命令读取日志。它作为由systemd管理的服务运行。</p><blockquote><p>使用systemd 的 Journal，如果您只需要本地日志，则不需要 syslog-ng (syslog-ng 是 syslog 的一种实现) </p></blockquote><p>systemd-journald将日志条目写入&#x2F;run&#x2F;log&#x2F;journal&#x2F; machine-id &#x2F;或&#x2F;var&#x2F;log&#x2F;journal&#x2F; machine-id &#x2F;中带有“.journal”后缀的文件中。如果守护程序不干净地停止，或者发现文件已损坏，则使用“.journal~”后缀重命名它们，并且systemd-journald开始写入新文件。当&#x2F;var&#x2F;log&#x2F;journal不可用或在<a href="https://www.freedesktop.org/software/systemd/man/latest/journald.conf.html#">&#x2F;etc&#x2F;systemd&#x2F;journald.conf(5)</a>配置文件中设置Storage&#x3D;volatile时，将使用&#x2F;run&#x2F;目录<br>systemd-journald程序以二进制格式而不是纯文本日志文件存储日志条目, 下面是一些常用命令的示例：</p><ul><li><p><code>journalctl -r</code>：以逆序的方式显示日志的所有内容。</p></li><li><p><code>journalctl -u UNIT</code>：显示与指定的UNIT文件相关联的日志条目。</p></li><li><p><code>journalctl -b[=ID]-r</code>：以逆序的方式显示自上次成功启动以来（或者指定的引导ID）的日志条目。</p></li><li><p><code>journalctl -f</code>：提供类似于tail -f（跟踪）的功能。</p></li></ul><h3 id="systemd-journald的工作原理"><a href="#systemd-journald的工作原理" class="headerlink" title="systemd-journald的工作原理"></a>systemd-journald的工作原理</h3><ul><li>它从&#x2F;dev&#x2F;kmsg读取内核日志数据。</li><li>它从GNU C库的syslog()函数读取应用程序日志数据，该函数通过符号链接 <strong>&#x2F;dev&#x2F;log</strong>（指向&#x2F;run&#x2F;systemd&#x2F;journal&#x2F;dev-log）。</li><li>它通过在&#x2F;run&#x2F;systemd&#x2F;journal&#x2F;stdout上监听AF_LOCAL(AF_UNIX)流套接字，接收来自systemd管理服务的日志数据。</li><li>它通过在&#x2F;run&#x2F;systemd&#x2F;journal&#x2F;socket上监听AF_LOCAL数据报套接字，接收使用systemd特定日志协议（如sd_journal_sendv()等）的程序发送的日志数据。<br>它将所有这些混合在一起。</li><li>它将日志写入一组系统范围和每个用户的日志文件，位于&#x2F;run&#x2F;log&#x2F;journal&#x2F;或&#x2F;var&#x2F;log&#x2F;journal&#x2F;中。</li><li>如果配置了转发到syslog，则它可以连接（作为客户端）到&#x2F;run&#x2F;systemd&#x2F;journal&#x2F;syslog上的AF_LOCAL数据报套接字，并将日志数据写入那里。</li><li>如果配置了，它还可以使用可写的&#x2F;dev&#x2F;kmsg机制将日志数据写入内核缓冲区。</li><li>如果配置了，它还可以将日志数据写入终端和控制台设备。</li></ul><p>如果此程序崩溃或服务停止，将会发生系统范围的问题。<br>systemd本身会将（某些）服务的标准输出和错误附加到&#x2F;run&#x2F;systemd&#x2F;journal&#x2F;stdout套接字上。因此，以正常方式记录到标准错误的守护进程的输出将被发送到日志中。<br><strong>这完全取代了klogd、syslogd、syslog-ng和rsyslogd</strong>。<br>现在这些都必须是systemd特定的。在systemd系统上，它们不能成为&#x2F;dev&#x2F;log的服务器端。而是采用以下两种方法之一：</p><ul><li>它们可以成为&#x2F;run&#x2F;systemd&#x2F;journal&#x2F;syslog的服务器端，并尝试连接并将日志数据写入其中（如果你还记得的话，systemd-journald会尝试连接并将日志数据写入其中）。几年前，人们会配置rsyslogd的imuxsock输入方法来实现这一点。  </li><li>它们直接从systemd日志中读取，使用一个特定于systemd的库来理解二进制日志格式，并可以监视日志文件和目录以获取新添加的条目。现在，人们会配置rsyslogd的imjournal输入方法来实现这一点。</li></ul><p><a href="https://unix.stackexchange.com/questions/205883/understand-logging-in-linux">以上内容来自于这里</a><br><a href="https://man.archlinux.org/man/core/systemd/systemd-journald.socket.8.en">systemd-journald官方文档</a><br><a href="https://systemd.io/JOURNAL_NATIVE_PROTOCOL/">有关systemd-journald更多的信息，详细介绍了&#x2F;run&#x2F;systemd&#x2F;journal目录下不同socket的作用</a></p><h3 id="linux系统日志"><a href="#linux系统日志" class="headerlink" title="linux系统日志"></a>linux系统日志</h3><p>rsyslog &#x2F; systemd-journald 守护进程既能接受用户进程输出的日志， 又能接受内核日志<br>用户进程是通过<a href="https://man7.org/linux/man-pages/man3/syslog.3.html">syslog</a>函数创建系统日志的，该函数将系统日志输出到一个UNIX本地域socket类型文件&#x2F;dev&#x2F;log中<br>内核日志由printk等函数打印至内核的环状缓存(ring buffer)中， 环状缓存的内容直接映射至&#x2F;proc&#x2F;kmsg 和 &#x2F;dev&#x2F;kmsg 中，<a href="https://unix.stackexchange.com/questions/585919/what-is-the-difference-between-proc-kmsg-and-dev-kmsg">proc&#x2F;kmsg 和 dev&#x2F;kmsg的区别</a>，rsyslog从&#x2F;proc&#x2F;kmsg读取，而journald可以从&#x2F;dev&#x2F;kmsg和&#x2F;proc&#x2F;ksmg读取。<br>下图总结了linux的日志系统:<br><img src="/2023/11/26/systemd/Snipaste_2023-12-09_00-28-33.jpg"></p><h3 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h3><p>&#x2F;etc&#x2F;init.d 是旧 SyS init 进程的一部分，并保留在基于 systemd 初始化的系统中以实现向后兼容性。<a href="https://en.wikipedia.org/wiki/Init">详情</a><br>sysctl 是一个实用程序，用于实时（&#x2F;proc&#x2F;sys）和通过 sysctl.conf 启动时设置内核参数。<br>systemd 是较新的初始化过程。<br>systemctl 是一个实用程序，用于启动&#x2F;停止和启用基于 systemd 的系统的服务。<br>journalctl，它是systemd用于读取systemd日志的实用程序。  </p><h3 id="systemd-coredump"><a href="#systemd-coredump" class="headerlink" title="systemd-coredump"></a>systemd-coredump</h3><p>核心转储(core dump)文件是程序收到信号或出现段错误崩溃，进程退出后所生成的文件</p><p><strong>systemd-coredump</strong>(可执行文件， 在arch linux环境下位于&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;systemd-coredump)会将核心转储记录到日志中，如果可能的话还包括回溯(backtrace)，并将核心转储（进程内存内容的映像）本身存储在 &#x2F;var&#x2F;lib&#x2F;systemd&#x2F;coredump 中的外部文件中<br>实际工作时，<strong>systemd-coredump</strong>被内核(<strong>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern</strong>)调用两次：一次作为处理程序，另一次在systemd-coredump@.service中将数据写入日志并处理保存核心文件。<br>当内核调用systemd-coredump来处理核心转储时，它在特权模式下运行，并将连接到systemd-coredump.socket单元创建的套接字，该套接字将生成一个非特权的systemd-coredump@.service实例来处理核心转储。因此，systemd-coredump.socket和systemd-coredump@.service是辅助单元，用于实际处理核心转储，并受到正常服务管理的限制。<br>还可以使用–backtrace选项调用systemd-coredump。在这种情况下，systemd-coredump期望在标准输入中以日志Journal Export Format [2]的形式包含一个日志条目。该条目应包含一个MESSAGE&#x3D;字段和调用者认为合理的任何其他元数据字段。systemd-coredump将以与从内核接收的核心转储相同的方式附加其他元数据字段。在这种模式下，不会将核心转储存储在日志中。</p><blockquote><p>使用systemd-coredump作为core dump的处理程序时， &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern中的内容类似于<br><code>kernel.core_pattern=|/usr/lib/systemd/systemd-coredump %P %u %g %s %t 9223372036854775808 %e</code><br>|使用管道表示core dump文件将通过管道传给后续命令,这里后续命令是systemd-coredump。百分号后各类参数表示对core dump文件进行重命名，如加入pid等等，具体内容在<a href="https://man.archlinux.org/man/core.5.en">core手册</a>  </p></blockquote><p>wsl2下systemd-coredump失效，&#x2F;var&#x2F;lib&#x2F;systemd&#x2F;coredump 中不会记录core dump文件，查看系统日志可以发现出现以下条目：<em>Failed to connect to coredump service: No such file or directory</em>，但是<strong>coredumpctl</strong>可以正常运行，&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;systemd-coredump文件也正常存在，该bug存在已久，一直没有得到修复  </p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>由于内核参数kernel.core_pattern是可以通过sysctl修改的，并且该参数的默认配置本身也来于&#x2F;usr&#x2F;lib&#x2F;sysctl.d&#x2F;50-coredump.conf， 所以我们可以临时修改或者永久修改该参数来改变core dump文件存储位置为&#x2F;tmp&#x2F;core(这里随喜好选择即可)  </p><blockquote><p>首先使用 <code>ulimit -c 1024</code> 来修改core dump文件的大小不为0，我这里修改为1024blocks，1blocks &#x3D; 512MB, 当然修改后只对目标用户当前进程及其子进程(session)有效，永久修改可以将其加入login shell的start up文件中(如&#x2F;etc&#x2F;profile)，或者在&#x2F;etc&#x2F;security&#x2F;limits.conf 中加入 一行 <code>* hard core 1024</code> 表示修改系统的硬限制为1024blocks  </p></blockquote><ul><li>临时修改, 重启后失效： <code>sudo sysctl -w kernel.core_pattern=/tmp/core</code></li><li>永久修改： 在&#x2F;etc&#x2F;sysctl.d&#x2F;core.conf中添加以下内容：<br><code>kernel.core_pattern=/tmp/core</code>之后运行<br><code>sysctl -p /etc/sysctl.d/50-coredump.conf</code><br><a href="https://github.com/microsoft/WSL/issues/1262">方法来源</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>GNU/linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>journal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux /proc文件夹下保存内核参数的各文件</title>
    <link href="/2023/11/25/file/"/>
    <url>/2023/11/25/file/</url>
    
    <content type="html"><![CDATA[<h2 id="etc"><a href="#etc" class="headerlink" title="etc"></a>etc</h2><table><thead><tr><th>文件名</th><th>对应内容</th></tr></thead><tbody><tr><td>resolve.conf</td><td>存储DNS服务器域名</td></tr><tr><td>host.conf</td><td>域名如何处理</td></tr><tr><td>hosts</td><td>ip到域名的本地缓存映射</td></tr></tbody></table><h2 id="proc"><a href="#proc" class="headerlink" title="proc"></a>proc</h2><table><thead><tr><th>文件名</th><th>对应内容</th></tr></thead><tbody><tr><td>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_rmem</td><td>tcp内核接收缓冲区</td></tr><tr><td>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_wmem</td><td>tcp内核接收缓冲区</td></tr><tr><td>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_window_scaling</td><td>开启窗口扩大因子</td></tr><tr><td>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_sack</td><td>开启选择性确认</td></tr><tr><td>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_timestamp</td><td>开启时间戳选项</td></tr><tr><td>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_congestion_control</td><td>拥塞控制算法</td></tr><tr><td>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_max_syn_backlog</td><td>半连接队列的长度</td></tr><tr><td>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn</td><td>全连接队列的长度</td></tr></tbody></table><p><a href="https://jaminzhang.github.io/linux/understand-Linux-backlog-and-somaxconn-kernel-arguments/">max_syn_backlog和somaxconn两个内核参数的区别</a><br><a href="https://www.starduster.me/2020/03/02/linux-network-tuning-kernel-parameter/">Linux网络优化：内核网络栈参数</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>多线程之间的同步</title>
    <link href="/2023/11/19/MultithreadSync/"/>
    <url>/2023/11/19/MultithreadSync/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#1-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5">1. 多线程同步</a><ul><li><a href="#11-%E4%BA%92%E6%96%A5%E9%94%81pthread_mutex">1.1. 互斥锁pthread_mutex</a><ul><li><a href="#111-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F%E4%B8%AD%E8%B0%83%E7%94%A8fork">1.1.1. 多线程程序中调用fork</a></li></ul></li><li><a href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8Fpthread_cond">条件变量pthread_cond</a></li><li><a href="#12-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86">1.2. 多线程信号处理</a></li></ul></li></ul><h2 id="1-多线程同步"><a href="#1-多线程同步" class="headerlink" title="1. 多线程同步"></a>1. 多线程同步</h2><h3 id="1-1-互斥锁pthread-mutex"><a href="#1-1-互斥锁pthread-mutex" class="headerlink" title="1.1. 互斥锁pthread_mutex"></a>1.1. 互斥锁pthread_mutex</h3><h4 id="1-1-1-多线程程序中调用fork"><a href="#1-1-1-多线程程序中调用fork" class="headerlink" title="1.1.1. 多线程程序中调用fork"></a>1.1.1. 多线程程序中调用fork</h4><ul><li>父进程使用fork()创建出的子进程会继承互斥锁的状态，所以如果父进程是多线程并且有一个线程锁住了mutex，则子进程创建时也会锁住（两个互斥锁分属于两个进程），此时子进程若调用pthread_mutex_lock则会导致死锁</li><li>我们可以在调用fork()之前使用pthread_atfork(prepare, parent, child)来保证父子进程中的互斥锁都有一个清晰的状态<ul><li>prepare，parent，child都为函数指针，prepare在fork调用之后，子进程创建之前使用，parent和child分别在fork调用返回之前，在父进程和子进程中使用，我们可以在prepare中对mutex上锁，在parent和child分别对其解锁来达到fork之后父子进程中的互斥锁都为解锁的</li></ul></li></ul><h3 id="条件变量pthread-cond"><a href="#条件变量pthread-cond" class="headerlink" title="条件变量pthread_cond"></a>条件变量pthread_cond</h3><ul><li>mutex用于同步线程对于共享数据的访问，conditional_variable用于同步线程之间共享数据的值</li><li>pthread_cond_signal不会解锁mutex（它不能，因为它没有对mutex的引用，所以它怎么知道要解锁什么？）事实上，发出信号的线程不需要与互斥体有任何连接， pthread_cond_wait在将等待线程放入等待队列之前先将mutex加锁，放入之后解锁，当线程被成功唤醒(即wait函数返回时)，mutex会再次被锁上，所以在pthread_cond_wait在被调用之后到调用线程被成功放入等待队列这段时间内，应该确保pthread_cond_signal和pthread_cond_broadcast等函数不会修改条件变量的值，将信号函数加上锁是个很好的方法，所以条件变量的通常用法如下所示：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">thread <span class="hljs-number">1</span>:<br>    <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br>    <span class="hljs-keyword">while</span> (!condition) <span class="hljs-comment">//等待某个条件变真，while循环防止假唤醒，cond通常被设为能够表示目标线程的唯一标识，从而唤醒一个指定线程</span><br>        <span class="hljs-built_in">pthread_cond_wait</span>(&amp;cond, &amp;mutex);<br>    <span class="hljs-comment">/* do something that requires holding the mutex and condition is true */</span><br>    <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br><br>thread2:<br>    <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br>    <span class="hljs-comment">/* do something that might make condition true */</span><br>    <span class="hljs-built_in">pthread_cond_signal</span>(&amp;cond);<br>    <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br></code></pre></td></tr></table></figure></li></ul><h3 id="1-2-多线程信号处理"><a href="#1-2-多线程信号处理" class="headerlink" title="1.2. 多线程信号处理"></a>1.2. 多线程信号处理</h3><ul><li>fork创建子进程，子进程会继承父进程的信号掩码并清除信号处理函数</li><li>对于线程来说，使用pthread_sigmask可以设置各线程的信号掩码，使用pthread_create创建的新线程也会继承该信号掩码</li><li>所有线程都共享信号处理函数，一个线程针对某信号设置的信号处理函数会覆盖其余线程的信号处理函数</li><li>当信号被产生(generate)后，内核会查找进程中没有为此信号设置掩码的线程,若没有，则会将该信号挂起(pending)，若有漏网之鱼，信号被成功投递(delivered)则信号处理函数被触发，若没有为此信号设置处理函数，则会触发进程的默认行为 </li><li>sigwait(set, signal)会等待信号集中的信号，知道发现某信号处于pending状态，这说明sigwait可以处理被信号掩码屏蔽的信号，它可以取出处于进程挂起信号集(sigpending()函数获取到的信号集)内的信号，之后实现对于信号的处理，这种处理方式是线程级别的，和signal或sigaction所设置的线程共享处理函数的方式不同，二者只能存在一个</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-title">sig_handler</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;<br>    <span class="hljs-type">sigset_t</span> * set = (<span class="hljs-type">sigset_t</span>*)arg;<br>    <span class="hljs-comment">/* sigset_t set1;</span><br><span class="hljs-comment">    sigemptyset(&amp;set1);</span><br><span class="hljs-comment">    sigaddset(&amp;set1, SIGQUIT);</span><br><span class="hljs-comment">    pthread_sigmask(SIG_UNBLOCK, &amp;set1, nullptr); */</span><br>    <span class="hljs-type">int</span> s, sig;<br>    <span class="hljs-keyword">for</span> (; ; ) &#123;<br>        s = <span class="hljs-built_in">sigwait</span>(set, &amp;sig);<br>        <span class="hljs-keyword">if</span>(s != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">handle_errno_en</span>(s, <span class="hljs-string">&quot;sigwait&quot;</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;signal handling thread got signal %d\n&quot;</span>, sig);<br>        &#125; <br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">5</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;got a signal\n&quot;</span>);<br>        <span class="hljs-comment">//break;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    <span class="hljs-type">pthread_t</span> thread;<br>    <span class="hljs-type">sigset_t</span> set;<br>    <span class="hljs-type">int</span> s;<br>    <span class="hljs-built_in">sigemptyset</span>(&amp;set);<br>    <span class="hljs-built_in">sigaddset</span>(&amp;set, SIGQUIT);<br>    <span class="hljs-built_in">sigaddset</span>(&amp;set, SIGUSR1);<br>    <span class="hljs-built_in">pthread_sigmask</span>(SIG_BLOCK, &amp;set, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">pthread_create</span>(&amp;thread, <span class="hljs-literal">nullptr</span>, sig_handler, &amp;set);<br>    <span class="hljs-built_in">pause</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>例程取自pthread_sigmask的man手册，它展示了如何在一个线程内实现对于信号的处理</p><blockquote><p>在多线程环境中，您可以使用sigwait UNIX系统调用来同步地处理异步信号。这可以帮助您的应用程序避免中断，并使其行为更加可预测。通常，专用的信号处理程序线程使用sigwait等待异步信号。为sigwait提供的信号掩码表示要等待哪些信号。在发送信号时，sigwait返回信号编号，信号处理程序线程执行信号处理程序。要通过sigwait接收异步信号，进程必须:<br>创建一个专用的信号处理程序线程，在该线程中调用sigwait来捕获异步信号。为这个线程屏蔽这些信号。对于所有其他线程，将set参数中指定的信号屏蔽为sigwait。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>GNU/linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>POSIX thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pacman - archlinu环境下的包管理程序</title>
    <link href="/2023/11/16/pacman/"/>
    <url>/2023/11/16/pacman/</url>
    
    <content type="html"><![CDATA[<p>上次使用pacman -Syu更新软件包后自动安装了开源版本的vscode，导致终端里使用code命令无法打开windows host中的官方版本vscode，今日卸载archlinux环境下安装的vscode，并使用pacman衍生的makepkg手动安装AUR库中的官方版本vscode，将一些心得和经验记录于下：</p><p><a href="https://archlinux.org/pacman/pacman.8.html#_remove_options_apply_to_em_r_em_a_id_ro_a">pacman官方文档</a></p><ol><li><p>软件包基础搜索及安装卸载<br><code>$ pacman -Ss 软件名称 //(搜索软件包)</code><br><code>$ pacman -S 软件名称 //(安装软件包)</code><br><code>$ pacman -Rs 软件名称 //(卸载软件包)</code><br><code>$ pacman -Syu (更新)</code></p></li><li><p>包的查询及清理<br>列出所有本地软件包（-Q,query查询本地；-q省略版本号）<br><code>$ pacman -Qq </code></p></li></ol><p>列出所有显式安装（-e,explicitly显式安装；-n忽略外部包AUR）<br><code>$ pacman -Qqe </code></p><p>列出自动安装的包（-d,depends作为依赖项）<br><code>$ pacman -Qqd </code></p><p>列出孤立的包（-t不再被依赖的”作为依赖项安装的包”）<br><code>$ pacman -Qqdt </code><br>注意：通常这些是可以妥妥的删除的。(sudo pacman -Qqdt | sudo pacman -Rs -)</p><ol start="3"><li><p>软件包和文件的查询<br>列出包所拥有的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs zsh">$ sudo pacman -Ql iw<br>iw /usr/<br>iw /usr/bin/<br>iw /usr/bin/iw<br>iw /usr/share/<br>iw /usr/share/man/<br>iw /usr/share/man/man8/<br>iw /usr/share/man/man8/iw.8.gz<br></code></pre></td></tr></table></figure><p>check 检查包文件是否存在（-kk用于文件属性）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs zsh">$ sudo pacman -Qk iw<br>iw: 7 total files, 0 missing files<br></code></pre></td></tr></table></figure><p>查询提供文件的包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs zsh">$ sudo pacman -Qo /usr/share/man/man8/iw.8.gz<br>/usr/share/man/man8/iw.8.gz is owned by iw 5.0.1-1<br></code></pre></td></tr></table></figure></li><li><p>查询包详细信息<br>查询包详细信息（-Qi;-Qii[Backup Files]）(-Si[Repository,Download Size];-Sii[Signatures,])<br><code>$ pacman -Qi 包名 </code><br>Repository 仓库名称（要联网用pacman -Si或Sii才能看到这一栏；）<br>Name 名称<br>Version 版本<br>Description 描述<br>Architecture 架构<br>URL 网址<br>Licenses 许可证<br>Groups 组<br>Provides 提供<br>Depends On 依赖于（依赖那些包）<br>Optional Deps 可选项<br>Required By 被需求的（被那些包需求）<br>Optional For 可选项<br>Conflicts With 与…发生冲突<br>Replaces 替代对象<br>Download Size 下载大小（要联网用pacman -Si或Sii才能看到这一栏；）<br>Installed Size 安装尺寸<br>Packager 包装者<br>Build Date 包装日期<br>Install Date 安装日期<br>Install Reason 安装原因（主动安装，还是被依赖自动安装）<br>Install Script 安装脚本<br>Validated By 验证者  </p></li><li><p>卸载软件包<br><code>pacman -Rs </code>会递归删除目标软件包及其包含的一些依赖，这些依赖不被其他包依赖的，但经过实践会发现，一些作为可选项被依赖的包也会被删除，所以保险起见，可以先使用<code>pacman -Rc</code>只删除当前安装包，之后使用<code>pacman -Rc $(pacman -Qtdq)</code>删除不再被需要的依赖，此时不包含可选依赖<br><img src="/2023/11/16/pacman/yilai.png"></p></li><li><p>makepkg安装AUR包<br>  <strong>makepkg是一个软件包自动编译脚本。使用时需要一个 Unix 环境和 PKGBUILD.使用之前，确保 base-devel包组 软件组已经安装。</strong><br>安装软件包分为以下几个步骤</p><ul><li>首先需要找到软件包构建所需文件，克隆其git存储库，在其AUR页面的“包详细信息”中标记为“Git Clone URL”。<br> <img src="/2023/11/16/pacman/clone.png"></li><li>之后切换到含有软件包的 PKGBUILD 文件的目录<br> <img src="/2023/11/16/pacman/mark.png"></li><li>使用如下命令编译软件包并安装软件包所需依赖<br> <code>$ makepkg --syncdeps / -s</code></li><li>最后安装软件包<br> <code>$ makepkg --install / -i</code></li><li>删除软件包时可以使用pacman对应命令</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>GNU/linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>package management</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读effective_modern_cpp有感</title>
    <link href="/2023/11/06/effective-modern-cpp/"/>
    <url>/2023/11/06/effective-modern-cpp/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#1-c%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85">1. c++知识点补充</a><ul><li><a href="#11-%E6%9D%82%E9%A1%B9">1.1. 杂项</a></li><li><a href="#12-c%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">1.2. c++异常处理</a></li><li><a href="#13-emplace_back%E7%BD%AE%E5%85%A5%E5%87%BD%E6%95%B0-vs-push_back%E6%8F%92%E5%85%A5%E5%87%BD%E6%95%B0">1.3. emplace_back置入函数 vs push_back插入函数</a><ul><li><a href="#131-%E4%B8%8D%E5%90%8C%E7%82%B9">1.3.1. 不同点</a></li><li><a href="#132-%E7%9B%B8%E5%90%8C%E7%82%B9">1.3.2. 相同点</a></li></ul></li><li><a href="#14-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">1.4. 智能指针</a><ul><li><a href="#141-make_shared--make_unique">1.4.1. make_shared &amp; make_unique</a></li></ul></li><li><a href="#15-%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%9F%E6%88%90">1.5. 特殊成员函数的生成</a></li><li><a href="#16-volatile-vs-atomic">1.6. volatile vs atomic</a><ul><li><a href="#161-stdatomic">1.6.1. std::atomic</a></li><li><a href="#162-keyword-volatile">1.6.2. keyword volatile</a></li></ul></li><li><a href="#17-move%E6%93%8D%E4%BD%9C">1.7. move操作</a></li></ul></li></ul><h1 id="1-c-知识点补充"><a href="#1-c-知识点补充" class="headerlink" title="1. c++知识点补充"></a>1. c++知识点补充</h1><h2 id="1-1-杂项"><a href="#1-1-杂项" class="headerlink" title="1.1. 杂项"></a>1.1. 杂项</h2><ol><li>c++11 lambda表达式不支持移动捕获和初始化捕获，c++14起开始支持，c++11可以使用std::bind实现近似功能</li><li>string内存存储在堆上，但是libstdc++实现了对于字节长度小于十五的短字符串的优化(sso)，string所存储的字符串被构造在栈内存中，不用重新从堆内申请内存，这样虽然string所提供的移动操作为常数时间，拷贝操作为线性时间，但对于短字符串来说移动所需时间不一定比拷贝短</li><li>当一个异常发生时，程序需要沿着运行时栈向上查找合适的异常处理器（catch block）。为了做到这一点，运行时栈必须处于可展开状态，即每个栈帧都有相应的信息来指示如何恢复函数的执行环境，并释放其中的资源。这些信息通常是由编译器在生成代码时添加的，称为展开信息（unwind information） 。当抛出异常并且控制从 try 块传递到处理程序时，C++ 运行时会调用自 try 块开始以来构造的所有自动对象的析构函数。这个过程称为堆栈展开（stack unwind）。</li><li>函数std::terminate()调用作为set_terminate()参数指定的函数, 程序会直接退出</li><li>在成员初始化器列表中可以聚合初始化聚合体，用花括号代替圆括号<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">  <span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span><br>&#123;<br>    <span class="hljs-type">int</span> a, b, i, j;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; r;<br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">int</span> i)<br>      : <span class="hljs-built_in">r</span>(a) <span class="hljs-comment">// 初始化 X::r 以指代 X::a</span><br>      , b&#123;i&#125; <span class="hljs-comment">// 初始化 X::b 为形参 i 的值</span><br>      , <span class="hljs-built_in">i</span>(i) <span class="hljs-comment">// 初始化 X::i 为形参 i 的值</span><br>      , <span class="hljs-built_in">j</span>(<span class="hljs-keyword">this</span>-&gt;i) <span class="hljs-comment">// 初始化 X::j 为 X::i 的值</span><br>    &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="1-2-c-异常处理"><a href="#1-2-c-异常处理" class="headerlink" title="1.2. c++异常处理"></a>1.2. c++异常处理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">D</span>(<span class="hljs-type">char</span>) <span class="hljs-keyword">try</span>: <span class="hljs-built_in">D</span>(<span class="hljs-number">55</span>)&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;D::D(char). Throws.\n&quot;</span>);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-number">0</span>;<br>  &#125;<span class="hljs-built_in">catch</span>(...)&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>  &#125;<br></code></pre></td></tr></table></figure><ol><li>所有异常类都可继承std::exception，并重载其what方法，注意what方法应该是不抛出异常的，即应做异常规格说明throw（），通常在函数签名尾部加入；</li><li>throw（A,B,C,D）声明函数可能抛出A,B,C,D中的任意一种异常</li><li>try-catch中try块可以抛出异常并被catch块捕捉到，catch后的小括号内可以指定你要处理的异常类型Myexception &amp;e,并在块中使用其what方法输出异常信息，也可以直接用一个变量缩写名代替特定异常</li></ol><h2 id="1-3-emplace-back置入函数-vs-push-back插入函数"><a href="#1-3-emplace-back置入函数-vs-push-back插入函数" class="headerlink" title="1.3. emplace_back置入函数 vs push_back插入函数"></a>1.3. emplace_back置入函数 vs push_back插入函数</h2><h3 id="1-3-1-不同点"><a href="#1-3-1-不同点" class="headerlink" title="1.3.1. 不同点"></a>1.3.1. 不同点</h3><ul><li>emplace_back使用完美转发，可以使用传入的实参通过容器元素的某一构造函数来直接在容器内进行构造; push_back只接受对象去插入，这里可能涉及一些隐式转换所导致的临时对象的构造与析构所带来的开销，emplace_back可以避免这一点</li><li>若接受某类型实参的构造函数是explicit的，则push_back会拒绝这一构造，因为内部其实动用了复制初始化，而explicit_back会动用直接初始化，调用声明explicit的构造函数时也可以通过编译</li><li>emplace_back在已经存在元素的地方进行置入时，比如某一vector的begin()处，此时会使用移动赋值函数，而这意味着临时对象的构造与析构，所以通过赋值操作增加元素时，emplace_back的优势会消失殆尽</li><li>若容器拒绝重复项作为新值，若std:set，则emplace_back通常会创建一个具有新值的节点，以便可以将该节点的值与现有容器中节点的值进行比较。如果要添加的值不在容器中，则链接该节点。然后，如果值已经存在，置入操作取消，创建的节点被销毁，意味着构造和析构时的开销被浪费了。这样的节点更多的是为置入函数而创建，相比起为插入函数来说。</li></ul><h3 id="1-3-2-相同点"><a href="#1-3-2-相同点" class="headerlink" title="1.3.2. 相同点"></a>1.3.2. 相同点</h3><ul><li>emplace_back和push_back在对于实参为同类型对象时都会选择拷贝&#x2F;移动构造函数</li></ul><h2 id="1-4-智能指针"><a href="#1-4-智能指针" class="headerlink" title="1.4. 智能指针"></a>1.4. 智能指针</h2><ol><li>unique_ptr move only</li><li>make函数也实现了完美转发，所以参数为构造函数的参数 </li><li>对于std::unique_ptr，只有这两种情景（自定义删除器和花括号初始化）使用make函数有点问题，使用make函数1是可以原子化操作创建指针，2是可以一次性创建控制块和对象，减少代码生成，提高执行代码的速度</li><li>weak_ptr shared_ptr之间可以相互创建，先创建shared_ptr保证有引用计数，之后赋值给weak_ptr，可以储存到容器中充当缓存来按索引检查是否过期，之后如果用户需要返回cache</li><li>unique只支持移动操作，移动构造表现为源指针置空，移动赋值表现为将被赋值指针销毁</li><li><strong>pImpl</strong></li></ol><p><strong>用来减少类的实现和类使用者之间的编译依赖的一种方法</strong>，将原本类中含有的对象剥离出去，只留下它的指针，如果实现文件中修改成员或函数定义，而类的使用方法没有什么变化， 那么在编译源文件时只需要重新编译实现文件就可以</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;                  <span class="hljs-comment">//跟之前一样，在“widget.h”中</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Widget</span>();<br>    ~<span class="hljs-built_in">Widget</span>();                  <span class="hljs-comment">//只有声明语句</span><br>    …<br><br><span class="hljs-keyword">private</span>:                        <span class="hljs-comment">//跟之前一样</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Impl</span>;<br>    std::unique_ptr&lt;Impl&gt; pImpl;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>unique_ptr 和 shared_ptr 的一大区别在于，unique_ptr对象本身has_a 默认或自定义删除器， 而shared_ptr内部只包含一个引用计数指针，指向<br>control_block, 其内包含引用计数，weak_count, 删除器对象等等(这在unique_ptr, shared_ptr两者不同构造函数上可以看出)，所以shared_ptr在生成速度和数据结构体积上远远大于unique_ptr   </li><li>默认删除器是一个函数对象，它使用delete来销毁内置于std::unique_ptr的原始指针. unique_ptr的析构函数会调用删除器的operator()， 而该方法使用C++11的特性static_assert(sizeof(资源类型))在编译阶段就确保原始指针指向的类型<em>不是一个不完整类型</em>， 根据上面widget例子来说，若Impl的定义在别的翻译单元，而析构函数在Widget.h文件定义或使用编译器自动生成的版本，则编译器会因为看不到类的定义而报错</li></ul><blockquote><p>诸如noexcept，sizeof， decltype， typeid（不用于指针指向的多态对象）， 统称为unevaluated expression</p></blockquote><ul><li>为了避免这种情况发生，在类定义时只声明默认构造和析构函数，具体实现放在实现文件中原始指针指向对象的类型定义之后实现, 移动赋值同理, 移动构造时，编译器自动生成的代码里，包含有抛出异常的事件，在这个事件里会生成销毁pImpl的代码。</li><li>shared_ptr则没有这种要求，它只要求构造时必须看到完整定义(在clang和gcc编译器上实验，尽管在头文件中就定义了空的默认构造函数， 编译器仍然可以<strong>正常编译</strong>，代码如下), 析构函数可以由编译器正常产出， 析构时shared_ptr使用指向control block的指针调用删除器的delete方法， 过程类似于虚函数调用，在运行期才能知道是否调用成功， 在代码中具体表现为shared_ptr构造基类子对象**__shared_ptr<em><em>时会使用static_assert来判断sizeof(资源类型)， ~~析构时也有一个get_del方法，该方法返回删除器的指针，但是没有static_assert， 只有static_cast一个void</em> to 删除器的指针Del</em>~~，不清楚是不是这样解释， 源码看的一知半解， 等之后更精进了再来解决吧</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs assembly">D::D() [base object constructor]:<br>        push    rbp<br>        mov     rbp, rsp<br>        sub     rsp, 16<br>        mov     QWORD PTR [rbp-8], rdi<br>        mov     rax, QWORD PTR [rbp-8]<br>        mov     rdi, rax<br>        call    std::shared_ptr&lt;D::Impl&gt;::shared_ptr() [complete object constructor]<br>        nop<br>        leave<br>        ret<br></code></pre></td></tr></table></figure><pre><code class="hljs">- 所以在使用unique_ptr来实现pImpl的近似代码如下：</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;widget.h&quot;</span>                 <span class="hljs-comment">//跟之前一样，在“widget.cpp”中</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;gadget.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Widget</span>::Impl &#123;               <span class="hljs-comment">//跟之前一样，定义Widget::Impl</span><br>    std::string name;<br>    std::vector&lt;<span class="hljs-type">double</span>&gt; data;<br>    Gadget g1,g2,g3;<br>&#125;<br><br>Widget::<span class="hljs-built_in">Widget</span>()                    <span class="hljs-comment">//跟之前一样</span><br>: <span class="hljs-built_in">pImpl</span>(std::<span class="hljs-built_in">make_unique</span>&lt;Impl&gt;())<br>&#123;&#125;<br><br>Widget::~<span class="hljs-built_in">Widget</span>()                   <span class="hljs-comment">//析构函数的定义（译者注：这里高亮）</span><br>&#123;&#125;<br><span class="hljs-comment">//Widget::~Widget() = default </span><br></code></pre></td></tr></table></figure><ul><li>而对std::shared_ptr而言，删除器的类型不是该智能指针的一部分，这让它会生成更大的运行时数据结构和稍微慢点的代码，但是当编译器生成的特殊成员函数被使用的时候，指向的对象不必是一个完整类型。</li></ul><blockquote><p>关于shared_ptr和unique_ptr的具体实现，请参见<a href="https://murphypei.github.io/blog/2022/03/shared-unique-ptr">这篇博客</a></p></blockquote><h3 id="1-4-1-make-shared-make-unique"><a href="#1-4-1-make-shared-make-unique" class="headerlink" title="1.4.1. make_shared &amp; make_unique"></a>1.4.1. make_shared &amp; make_unique</h3><p>根本上讲，像std::shared_ptr和std::unique_ptr这样的资源管理类的高效性是以资源（比如从new来的原始指针）被立即传递给资源管理对象的构造函数为条件的。实际上，std::make_shared和std::make_unique这样的函数自动做了这些事，是使它们如此重要的原因。若不使用make_shared或make_unique，我们应确保在资源的获取（比如使用new）和资源管理对象的创建之间没有其他操作。</p><p>比如在 <code>std::list&lt;std::shared_ptr&lt;Widget&gt;&gt; ptrs</code>中分别使用push_back和emplace_back插入带自定义删除器的shared_ptr时，使用<strong>push_back</strong>插入临时对象的方法可以保证异常安全，而<strong>emplace_back</strong>由于new之后没有及时创建资源管理对象，而是先在list分配<strong>节点</strong>内存，导致内存泄漏(比如list分配内存过程中内存溢出异常被抛出, 随着异常的传播，push_back可以销毁临时对象从而达成对堆内存的回收，而emplace_back此时只有一个new出来的原始指针指向堆内存，但却因为异常丢失，导致内存泄漏)</p><blockquote><p><strong>节点</strong>： 大多数标准库容器都是基于节点的。例外的容器只有std::vector，std::deque，std::string。（std::array也不是基于节点的，但是它不支持置入和插入，所以它与这儿无关。）在不是基于节点的容器中，你可以依靠emplace_back来使用构造向容器添加元素，对于std::deque，emplace_front也是一样的。</p></blockquote><p>所以将智能指针置入&#x2F;插入list正确且美观的方法是，先在list外构建一个智能指针，之后将其转为右值移动构造置入&#x2F;插入进list</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::shared_ptr&lt;Widget&gt; <span class="hljs-title">spw</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget,      <span class="hljs-comment">//创建Widget，让spw管理它</span></span></span><br><span class="hljs-params"><span class="hljs-function">                            killWidget)</span></span>;<br>ptrs.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(spw));              <span class="hljs-comment">//添加spw右值</span><br><span class="hljs-comment">//ptrs.emplace_back(std::move(spw));</span><br></code></pre></td></tr></table></figure><h2 id="1-5-特殊成员函数的生成"><a href="#1-5-特殊成员函数的生成" class="headerlink" title="1.5. 特殊成员函数的生成"></a>1.5. 特殊成员函数的生成</h2><ol><li>拷贝，或者移动操作，若有一方是用户定义的，则不会生成另一方，并且对于两个移动操作来说，显式定义一方也会导致另一方不会被自动生成</li><li>所以仅当下面条件成立时才会生成移动操作（当需要时）：<ul><li>类中没有拷贝操作</li><li>类中没有移动操作</li><li>类中没有用户定义的析构，但如果出现定义析构，编译器也会自动生成拷贝操作</li></ul></li><li>注意没有“成员函数模版阻止编译器生成特殊成员函数”的规则</li></ol><h2 id="1-6-volatile-vs-atomic"><a href="#1-6-volatile-vs-atomic" class="headerlink" title="1.6. volatile vs atomic"></a>1.6. volatile vs atomic</h2><h3 id="1-6-1-std-atomic"><a href="#1-6-1-std-atomic" class="headerlink" title="1.6.1. std::atomic"></a>1.6.1. std::atomic</h3><ol><li>原子化读写操作，多线程访问时不会产生数据竞争，而且也可以用来当作条件变量，单纯使用时反应函数需要不断轮询，会增加线程开销，线程阻塞而不挂起，内存中的资源一直被占用</li><li>会限制编译器和底层硬件对于代码执行顺序的重排，维护atomic的顺序一致性模型</li><li>无法进行拷贝操作，但是可以进行load和store操作，但是若出现<strong>冗余访问</strong>或者<strong>无用存储</strong>, 编译器也会进行优化</li></ol><h3 id="1-6-2-keyword-volatile"><a href="#1-6-2-keyword-volatile" class="headerlink" title="1.6.2. keyword volatile"></a>1.6.2. keyword volatile</h3><p>避免编译器对于代码的优化，在变量用来存储<strong>做内存IO映射内存</strong>上报的数据时，非常有用</p><ol><li>std::atomic用在并发编程中，对访问特殊内存没用。</li><li>volatile用于访问特殊内存，对并发编程没用。<br>因为std::atomic和volatile用于不同的目的，所以可以结合起来使用：<br><code>volatile std::atomic&lt;int&gt; vai;          //对vai的操作是原子性的，且不能被优化掉</code><br>  如果vai变量关联了内存映射I&#x2F;O的位置，被多个线程并发访问，这会很有用。</li></ol><h2 id="1-7-move操作"><a href="#1-7-move操作" class="headerlink" title="1.7. move操作"></a>1.7. move操作</h2><ol><li>std::move只是强制将左值&#x2F;右值统统转换为右值<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>std::remove_reference&lt;T&gt;::<span class="hljs-function">type &amp;&amp; <span class="hljs-title">move</span><span class="hljs-params">(T&amp;&amp; param)</span></span>&#123;<br>    <span class="hljs-keyword">using</span> Returntype =  std::remove_reference&lt;T&gt;::type&amp;&amp;;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;Returntype&gt;(param);<br>&#125; <br></code></pre></td></tr></table></figure></li><li>虽然string提供了<strong>常数时间</strong>的移动操作和<strong>线性时间</strong>的复制操作由于string的小字符串优化(SSO,指的是当字符串的长度小于某数时，编译器会将其存入缓冲区中，而不是在堆上分配内存，这个长度每个编译器的实现略有区别)，所以此时对字符串的移动操作不一定比复制操作时间快很多</li></ol>]]></content>
    
    
    <categories>
      
      <category>cpp related</category>
      
    </categories>
    
    
    <tags>
      
      <tag>smart-pointer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux高性能服务器的搭建</title>
    <link href="/2023/11/03/linux-high-performanceserver/"/>
    <url>/2023/11/03/linux-high-performanceserver/</url>
    
    <content type="html"><![CDATA[<h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><ol><li><p>阻塞IO和非阻塞IO的区别就在于对非就绪事件的处理， 对于设置了O_NONBLOCK的文件描述符来说，若此时文件描述符非可读或者可写，针对其进行的系统调用会返回-1，设置errno，而对未设置的文件描述符的connect，recv，send会阻塞进程</p></li><li><p>管道pipe是环形缓冲区</p></li><li><p>O_NONBLOCK对一般文件而言没有什么影响，所有一般文件都是可读或者可写的，它主要用来在fcntl时设置socket或者字符设备的属性，详情请见<a href="https://www.cnblogs.com/hustxujinkang/p/5072270.html">O_NONBLOCK on regular file</a></p><blockquote><p>字符设备，即流设备，如tty，pts，拥有自己的缓冲区，并且采用行缓冲，每个进程的STDIN_FILENO,STDOUT_FILENO软链接到当前终端中（&#x2F;dev&#x2F;stdin及其他也和这三个文件描述符软链接），所以使用splice等系统调用从标准输入读取中会读取换行符</p></blockquote></li><li><p>同步或者异步I&#x2F;O主要是指访问数据的机制(即实际I&#x2F;O操作的完成方式)，同步一般指主动请求并等待I&#x2F;O操作完毕的方式，I&#x2F;O操作未完成前，会导致应用进程挂起；而异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知（异步的特点就是通知）,这可以使进程在数据读写时也不阻塞。阻塞或者非阻塞I&#x2F;O主要是指I&#x2F;O操作第一阶段的完成方式(进程访问的数据如果尚未就绪)，即数据还未准备好的时候，应用进程的表现，如果这里进程挂起，则为阻塞I&#x2F;O，否则为非阻塞I&#x2F;O。说白了就是阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，<br>而非阻塞方式下，读取或者写入函数会立即返回一个状态值。<br> 而在并发模式中，同步指的是程序严格按照代码顺序执行， 异步指的是程序的执行需要系统事件来驱动</p></li></ol><h2 id="关于splice函数的盲点"><a href="#关于splice函数的盲点" class="headerlink" title="关于splice函数的盲点"></a>关于splice函数的盲点</h2><p>   SPLICE_F_MORE对于写入端是socket的情况下有效，如果设置了 SPLICE_F_MORE 那么会追加 MSG_MORE flag；如果当前 pipe 中还有其他的 page，则追加 MSG_SENDPAGE_NOTLAST flag。</p><p>首先来看 MSG_MORE 的作用，熟悉 TCP 的应该已经知道了这个标志表示调用者有更多的数据要发送。在 TCP socket 中，该标志用于获取与 TCP_CORK 相同的效果，不同之处在于该标志可以在每次调用时设置。顾名思义 TCP_CORK 就是给 TCP 发送数据的时候加了一个木塞子。往这个 socket 写入的数据都会聚集起来。虽然堵上了塞子，但是数据总得发送，取决于:</p><ul><li><p>程序取消设置 TCP_CORK 这个选项</p></li><li><p>socket 聚集的数据大于一个 MSS 的大小</p></li><li><p>自从堵上塞子写入第一个字节开始，已经经过 200ms</p></li><li><p>socket 被关闭了 </p><p>  此外，当设置SPLCICE_NONBLOCK标志时，若读取端设置为非阻塞且没有准备好数据，则会触发EAGAIN错误</p></li></ul><h2 id="三种设备驱动"><a href="#三种设备驱动" class="headerlink" title="三种设备驱动"></a>三种设备驱动</h2><p>即为dev目录下的设备文件是如何实际硬件进行交互的，一般是通过驱动程序进行</p><p><strong>进一步-VFS虚拟文件系统</strong></p><h2 id="Linux中的文件描述符与打开文件之间的关系"><a href="#Linux中的文件描述符与打开文件之间的关系" class="headerlink" title="Linux中的文件描述符与打开文件之间的关系"></a>Linux中的文件描述符与打开文件之间的关系</h2><p>两个不同的文件描述符，若指向同一个打开文件句柄，将共享同一文件偏移量</p><p><a href="https://www.linuxprobe.com/linux-file-descriptor.html">详情</a></p><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><table><thead><tr><th>常用信号</th><th></th><th></th></tr></thead><tbody><tr><td>信号</td><td>含义</td><td>默认行为</td></tr><tr><td>SIGINT</td><td>键盘输入以中断进程(Ctrl + C)</td><td>term(终止进程)</td></tr><tr><td>SIGQUIT</td><td>键盘输入使进程退出(Ctrl + )</td><td>core（结束进程并生成核心转储文件）</td></tr><tr><td>SIGSTOP</td><td>暂停进程(Ctrl + S), 该信号不得被捕获或者忽略</td><td>stop（暂停进程）</td></tr><tr><td>SIGCHLD</td><td>子进程状态发生变化（退出或者暂停）</td><td>ign(忽略信号)</td></tr><tr><td>SIGPIPE</td><td>socket连接对方的读端已经关闭或者管道的读端已经关闭，此时发送方使用send或者往管道的写端写数据，都会触发该信号</td><td>term</td></tr><tr><td>SIGHUP</td><td>控制终端被挂起(Ctrl + Z)，可以使用kill -HUP来向进程发送该信号</td><td>term</td></tr><tr><td>SIGTERM</td><td>kill命令默认发送信号</td><td>term</td></tr></tbody></table><ol><li>信号处理函数指针__sighandler_t<ul><li>系统定义两种处理函数<ul><li>SIG_DFL (__sighandler_t) 0 采用信号默认处理方式 &#x2F;<em>整形-&gt;函数指针强制类型转换</em>&#x2F;</li><li>SIG_IGN (__sighandler_t) 1 忽略信号</li></ul></li></ul></li><li>自定义信号处理函数：sigaction系统调用<br>参数：<ul><li>sig，要捕获的信号</li><li>act，struct sigaction*<ul><li>结构体中的sa_handler是信号处理函数指针，用于指定函数处理函数</li><li>sa_mask，类型为信号集sigset_t，用于设定增加的信号掩码（在原进程基础上）<ul><li>sa_mask指定了一个信号集的掩码，这些信号在信号处理程序执行期间应该被阻塞（<strong>即添加到调用信号处理程序的线程的信号掩码中</strong>）。此外，除非使用了SA_NODEFER标志，否则触发处理程序的信号也将被阻塞。</li></ul></li><li>sa_flags, 整形数据，用于设置程序接收到信号时的行为<ul><li>SA_RESTART, 含义是重新调用被该信号终止的系统调用</li><li>SA_NODEFER, 一般情况下，在接收信号并进入其信号处理函数时，该信号会被加入至线程的信号掩码中，防止接收同种信号，引发竞态条件，设置该选项可以使得同种信号也被线程接收<br>成功返回0，失败返回-1并设置errno</li></ul></li></ul></li></ul></li><li>struct sigset 用于表示一组信号集，其中定义了一个长整型数组，每个元素的每个位都代表着一个信号, 这组信号集可以用来设置进程掩码，标志着某个信号将会被<strong>阻塞</strong>，手册上给出了掩码和阻塞的说明：<ul><li>一个信号可能会被阻塞，这意味着直到解除阻塞之前它将不会被传递。在生成和传递之间的时间内，信号被称为待处理的(pending)。</li><li>进程中的每个线程都有一个独立的信号掩码，它指示线程当前阻止的信号集。线程可以使用pthread_sigmask(3)来操作其信号掩码。在传统的单thread线程应用程序中，可以使用sigprocmask(2)来操作信号掩码。</li></ul></li><li>sigprocmask函数也可以用sigset来指定新的进程掩码，通过how参数可以设置新掩码集和当前掩码集的交互方式</li><li>可以使用sigpending函数获取被挂起的信号集，当通过设置进程掩码导致新的信号被屏蔽时，新的信号会被操作系统设置为挂起的信号，若取消对信号的屏蔽，则可以立刻被进程接收到 </li><li>fork出的子线程会继承父线程的信号集合，但会拥有空的挂起信号集</li><li><strong>正在阻塞</strong>的系统调用可以被信号处理函数中断(interrupt), 若在sigaction建立信号处理函数时设置了SA_RESTART标志，则某些系统调用可以在信号处理函数返回之后重启(restart), 有些则不论是否设置该标志都会<strong>失败</strong>，并设置errno为EINTR<ul><li>SA_RESTART标志有效的系统调用包括： read，write，ioctl，open(如果能被阻塞，比如当打开FIFO时)，以及常见的socket接口</li><li>SA_RESTART标志无效的系统调用包括： 通过setsockopt设置socket选项为超时SO_RECVTIMEO的输入输出socket接口， 以及IO复用select，poll，epoll_wait</li><li>sleep函数永远不会重启但会成功返回，并返回剩余的sleep秒数</li></ul></li><li>当挂起进程的控制终端时，SIGHUP将被触发，对于没有控制终端的网络后台程序来说，通常利用SIGHUP信号来强制服务器重读配置文件</li><li>linux环境下，内核通知应用程序**带外数据(大小1字节，通常被tcp接收端存储到特殊缓存中，称为带外缓存)**到来的方式有两种：<ul><li>使用IO复用函数监听事件集中的异常事件，select等系统调用在接收到带外数据时将返回，并向应用程序报告socket上的异常事件，此时应用程序可以调用FD_ISSET等函数来查看异常事件是否发生</li><li>使用SIGURG信号，此时应用程序可设置信号处理函数来读取带外数据<blockquote><p>对于带外缓存来说，可以设置连接socket的SO_OOBINLINE选项来将带外数据存放在接收端的普通数据输入队列中，此时我们不能使用MSB_OOB来读取数据</p></blockquote></li></ul></li></ol><h2 id="进程间通信-IPC"><a href="#进程间通信-IPC" class="headerlink" title="进程间通信 IPC"></a>进程间通信 IPC</h2><ol><li><p>如果文件事先已经存在，<br>open(pathname, O_RDWR | O_CREAT，0666);  打开成功，返回一个大于0的fd<br>open(pathname, O_RDWR | O_CREAT | O_EXCL，0666); 打开失败，返回-1</p><p>O_EXCL表示的是：如果使用O_CREAT时文件存在，就返回错误信息，它可以测试文件是否存在。并且此时检查文件和打开文件是原子性操作，避免了进程临界区竞争</p><blockquote><p>在NFS（网络文件系统）上，O_EXCL可能不是原子性的，此时可以调用link系统调用创建hard link来查看文件是否存在(通过使用stat可以查看st_nlink的数量)</p></blockquote></li><li><p>IPC对象包括：信号量（semaphore），共享内存，消息队列, System V 和 POSIX对于三种进程间通信的接口不同，具体内容如下：</p></li></ol><table><thead><tr><th>特性</th><th>System V IPC</th><th>POSIX IPC</th></tr></thead><tbody><tr><td>IPC 机制</td><td>管道、命名管道、消息队列、信号、信号量、共享内存、套接字、Unix 域套接字</td><td>管道、命名管道、消息队列、信号量、共享内存、套接字</td></tr><tr><td>共享内存接口调用</td><td>shmget()，shmat()，shmdt()，shmctl()</td><td>shm_open()，mmap()，shm_unlink()</td></tr><tr><td>消息队列接口调用</td><td>msgget()，msgsnd()，msgrcv()，msgctl()</td><td>mq_open()，mq_send()，mq_receive()，mq_unlink()</td></tr><tr><td>信号量接口调用</td><td>semget()，semop()，semctl()</td><td>命名信号量：sem_open()，sem_close()，sem_unlink()，sem_post()，sem_wait()，sem_trywait()，sem_timedwait()，sem_getvalue() 无名或基于内存的信号量：sem_init()，sem_post()，sem_wait()，sem_getvalue()，sem_destroy()</td></tr><tr><td>IPC 对象的标识</td><td>键和标识符</td><td>名称和文件描述符</td></tr><tr><td>监视 POSIX 消息队列</td><td>select()，poll()，epoll()</td><td>NA</td></tr><tr><td>消息队列控制</td><td>msgctl()</td><td>提供函数(mq_getattr()和mq_setattr())</td></tr><tr><td>线程同步</td><td>互斥锁、条件变量、读写锁</td><td>多线程安全</td></tr><tr><td>消息队列通知</td><td>NA</td><td>提供少量通知特性(例如mq_notify())</td></tr><tr><td>状态&#x2F;控制操作</td><td>需要系统调用(shmctl())、命令(ipcs, ipcrm)</td><td>可使用系统调用(例如fstat(), fchmod())检查和操作共享内存对象</td></tr><tr><td>共享内存段的大小</td><td>在创建时固定(通过shmget())</td><td>可使用ftruncate()调整底层对象的大小，然后重新创建映射使用munmap()(或Linux特定的mremap())</td></tr></tbody></table><h2 id="进程的退出"><a href="#进程的退出" class="headerlink" title="进程的退出"></a>进程的退出</h2><ul><li><p>当exec失败时，应该使用_exit（或其同义词_Exit）来终止子进程，因为在这种情况下，子进程可能通过调用其atexit处理程序、调用其信号处理程序和&#x2F;或刷新缓冲区来干扰父进程的外部数据（文件）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">switch</span> (fork()) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>    <span class="hljs-comment">// we&#x27;re the child</span><br>    <span class="hljs-built_in">execlp</span>(<span class="hljs-string">&quot;some&quot;</span>, <span class="hljs-string">&quot;program&quot;</span>, <span class="hljs-literal">NULL</span>);<br>    _exit(<span class="hljs-number">1</span>);  <span class="hljs-comment">// &lt;-- HERE</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>:<br>    <span class="hljs-comment">// error, no fork done ...</span><br>  <span class="hljs-keyword">default</span>:<br>    <span class="hljs-comment">// we&#x27;re the parent ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>当使用fork()，尤其是vfork()时，exit()和_exit()之间存在一些差异，这些差异变得很重要。</p></li><li><p>fork()会将父进程的虚拟地址空间复制一份给子进程，并在需要时写时复制(copy on write), 否则二者映射到内存同一位置，若某方对数据发生了改变，则父进程将复制一份数据给子进程，此时二者的函数调用栈在内存中的位置不同，vfork()则是二者共享一片内存区域，此时子进程若使用return语句，则会弹栈，破坏父进程函数调用栈，exit()则不会更改函数栈结构，而是将回收内存任务交给操作系统，接下来看一个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stack1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">vfork</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stack2</span><span class="hljs-params">()</span> </span>&#123;<br>    _exit(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">stack1</span>();<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d goes 1\n&quot;</span>, <span class="hljs-built_in">getpid</span>());<br>    <span class="hljs-built_in">stack2</span>();<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d goes 2\n&quot;</span>, <span class="hljs-built_in">getpid</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><ul><li>父进程stack1后阻塞在vfork()调用，子进程从vfork()返回，并执行stack2()并退出, 在执行stack2()之前子进程会将main函数的返回地址改为stack2()的下一句，所以父进程从stack1()返回时，会执行goes2语句，很神奇！</li></ul><ul><li><p>exit()和_exit()的基本区别在于前者执行与库中用户模式结构相关的清理，并调用用户提供的清理函数，而后者仅执行进程的内核清理,比如关闭所有文件描述符。</p></li><li><p>在fork()的子分支中，通常不使用exit()，因为这可能导致stdio缓冲区被刷新两次，并且临时文件被意外删除。在C++代码中，情况更糟，因为静态对象的析构函数可能会被错误地运行。（有一些不寻常的情况，如守护进程，其中父进程应调用_exit()而不是子进程；适用于绝大多数情况的基本规则是：每次进入main时只应调用一次exit()。）</p></li><li><p>在vfork()的子分支中，使用exit()甚至更加危险，因为它会影响父进程的状态。</p></li><li><p>从glibc 2.27开始，abort()函数终止进程时不会刷新流。POSIX.1允许两种可能的行为，即abort()函数“可能会尝试对所有打开的流执行fclose()操作”。</p><ul><li>std::terminate调用的就是abort()函数</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>GNU/linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>POSIX system call</tag>
      
      <tag>filesystem</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux/cmake 常用命令</title>
    <link href="/2023/09/30/linux-&amp;-cmake-commands/"/>
    <url>/2023/09/30/linux-&amp;-cmake-commands/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#linux-%E5%91%BD%E4%BB%A4">Linux 命令</a></li><li><a href="#valgrind-%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7">valgrind 调试工具</a></li><li><a href="#%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%B5%8B%E5%B7%A5%E5%85%B7">系统监测工具</a></li><li><a href="#cmake">cmake</a><ul><li><a href="#cmake%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B">cmake具体流程</a></li><li><a href="#cmake-commands">cmake commands</a></li></ul></li></ul><h2 id="Linux-命令"><a href="#Linux-命令" class="headerlink" title="Linux 命令"></a>Linux 命令</h2><ol><li><strong>ldconfig</strong><br>创建所需的链接并缓存到标准库目录中找到的最新共享库.</li><li><strong>ldd filename</strong><br>显示特定Linux命令需要运行的共享对象文件。  </li><li><strong>file filename</strong><br>展示文件属性</li><li><strong>set</strong><br><a href="https://segmentfault.com/a/1190000013356532">当前终端进程的shell variable，不会遗传给子进程，注意和environment variable做区分</a></li><li><strong>ar -t</strong><br>对于静态库，显示存档archive的内容</li><li><strong>du</strong><br>展示目录下文件大小</li><li><strong>gcc -I . -c mathDemo.c</strong><br>-I . means tell gcc search headerfiles in the specific folder, in the example is .</li><li><strong>environment variable (globally)</strong></li></ol><ul><li>etc&#x2F;zsh&#x2F;zprofile (source) </li><li>etc&#x2F;profile (source) </li><li>etc&#x2F;proifile.d&#x2F;*sh</li></ul><ol start="9"><li><strong>environment variable (per-user)</strong></li></ol><ul><li>~&#x2F;.zshenv</li><li>~&#x2F;.zshrc</li></ul><ol start="10"><li><p><strong>zshenv</strong> 是在任何情况下都会被读取的文件，它用于设置一些全局的环境变量，比如 $PATH, $EDITOR 等。<a href="https://juejin.cn/post/7128574050406367269https://blog.csdn.net/ber_bai/article/details/122257534">它通常不用于设置交互式 shell 的选项，比如 $PROMPT, aliases, functions 等。</a></p><ul><li><a href="https://juejin.cn/post/7128574050406367269https://bing.com/search?q=.zshenv+%E5%92%8C+.zshrc+%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB&form=SKPBOT">zshrc 是只在交互式 shell 中被读取的文件，它用于设置一些交互式 shell 的选项，比如 $PROMPT, aliases, functions 等。它通常在 .zprofile 之后被加载，所以可以覆盖.zprofile 中的一些设置。</a></li><li><a href="https://einverne.github.io/post/2023/01/zprofile-zshrc.html">一般来说，.zshenv 用于设置一些不会改变的环境变量，而 .zshrc 用于设置一些会根据个人喜好和需求变化的交互式 shell 的选项</a></li></ul></li><li><p><strong>chmod u&#x2F;g&#x2F;a +s</strong><br>设置目标文件的set-user-id&#x2F;set-group-id&#x2F;全部标志，使得文件可以被不同UID用户执行时设置EUID为ownerID&#x2F;groupID，前提是设置others的权限为可以执行文件</p><ul><li>数字模式下set-user-id 对应的比特位值为4， set-group-id 对应的比特位值为2，他们对应的比特位在u，g，o之前, 这个比特位表示执行该文件的真实用户在执行该文件时可以获得该文件的拥有者的特权</li><li>补充linux的setuid函数<ul><li>如果调用进程具有特权（有效用户为0&#x2F;root），则此函数将进程的实际用户ID和有效用户ID都设置为newuid。如果有的话，它还会删除进程的文件用户ID。newuid可以是任何合法值。（一旦完成此操作，将无法恢复旧的有效用户ID。），所以对于特权进程而言，如果只是暂时想要放弃特权，应该使用<strong>seteuid</strong>函数</li><li>如果调用进程不具有特权，则该函数和seteuid类似，只是将该函数将进程的有效用户ID设置为neweuid，前提是进程被允许更改其有效用户ID。具有特权的进程（有效用户ID为零）可以将其有效用户ID更改为任何合法值。具有文件用户ID的非特权进程可以将其有效用户ID更改为其实际用户ID或文件用户ID。</li></ul></li></ul></li><li><p><strong>chmod u&#x2F;g&#x2F;o&#x2F;a +&#x2F;-&#x2F;&#x3D; r&#x2F;w&#x2F;</strong><br>操作符+会将所选文件的模式位添加到每个文件的现有模式位中；-会将它们移除；&#x3D;会将它们添加，并且将未提及的位移除，但目录的未提及的设置用户和组ID位不受影响。</p><ul><li>the user who owns it (u), other users in the file’s group (g), other users not in the file’s group (o)</li><li>数字模式下u对应的比特位为第二位，之后是g，最后为o，位上的值4代表着读，2代表着写，1代表可执行</li></ul></li><li><p><strong>chmod -r</strong><br>表示递归设置目录文件下的所有文件**</p><blockquote><p><a href="https://chmodcommand.com/chmod-2755/">模拟chmod命令的网站</a></p></blockquote></li><li><p><strong>chown root:root</strong><br>设置owner为root，group为root</p></li><li><p><strong>ps command</strong><br><img src="/2023/09/30/linux-&-cmake-commands/ps%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E7%BB%84%E5%85%B3%E7%B3%BB.png" alt="使用ps查看进程组，会话组之间关系"><br> - 这条命令创建出三个进程，一个会话，两个进程组，bash是ps和less的父进程，则ps和less的PPID对应bash的PID<br> - bash命令是整个会话组的首领（会话组：一些有关联的进程组），会话首领对应的SID和进程组PGID以及PID都是相同的<br> - bash进程fork出两个子进程ps和less，ps和less同属一个进程组，ps是该进程组的首领<br>ps -ef 列出所有进程(all process)的详细信息(full-format, including command lines)<br>ps aux 列出前台进程(all with tty)，后台进程(processes without controlling ttys)<br><img src="/2023/09/30/linux-&-cmake-commands/pscmd.png"><br><img src="/2023/09/30/linux-&-cmake-commands/stat.png"><br>其中STAT状态位常见的状态字符有<br>D      &#x2F;&#x2F;无法中断的休眠状态（通常 IO 的进程）<br>R      &#x2F;&#x2F;正在运行可中在队列中可过行的；<br>S      &#x2F;&#x2F;处于休眠状态；<br>T      &#x2F;&#x2F;停止或被追踪；<br>W      &#x2F;&#x2F;进入内存交换 （从内核2.6开始无效）；<br>X      &#x2F;&#x2F;死掉的进程 （基本很少见）；<br>Z      &#x2F;&#x2F;僵尸进程；<br>&lt;      &#x2F;&#x2F;优先级高的进程<br>N      &#x2F;&#x2F;优先级较低的进程   ****<br>L      &#x2F;&#x2F;有些页被锁进内存；<br>s      &#x2F;&#x2F;进程的领导者（在它之下有子进程）；<br>l      &#x2F;&#x2F;多线程，克隆线程（使用 CLONE_THREAD, 类似 NPTL pthreads）；<br>+      &#x2F;&#x2F;位于后台的进程组；  </p></li><li><pre><code class="hljs">**cat**      </code></pre><ul><li>cat filename 显示文件内容</li><li>cat &gt; filname1 将标准输入中的内容重定向到filename1中（用ctrl+d作为EOF结束输入）</li><li>cat &gt; filename2 &lt;&lt;EOF 将开始标记EOF和结束标记EOF之间的标准输入中的内容重定向到fiilname2</li><li>cat &gt;&gt; filename3 在filename3中追加内容<br>更多关于重定向的内容：<a href="https://www.runoob.com/linux/linux-shell-io-redirections.html">Shell 输入&#x2F;输出重定向</a></li></ul></li><li><p><strong>wc -l filename</strong><br> 计算file中的行数</p></li><li><p><strong>telnet开启本地回显</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">telnet <br>set localecho<br>open &lt;host ip&gt; &lt;port&gt; <br></code></pre></td></tr></table></figure></li><li><p>基本正则表达式(BRE)和扩展正则表达式(ERE)是指定模式语法的两种变体。sed命令使用BRE语法<br>在对比如小括号()进行处理时两者有所区别，在BRE内，单独小括号是指文本中的小括号，加了backflash(也就是反斜杠)转义之后是模式匹配的意义，ERE相反，<a href="https://www.runoob.com/regexp/regexp-syntax.html">ERE的详细信息</a><br><code>sed -i &#39;s/\(.*\)apple/\1banana/g&#39; fruits.txt(需要修改的文件名)</code><br>解释:  </p><ul><li>s表示用字符串匹配模式，标准写法为”s&#x2F;pattern&#x2F;replacement&#x2F;flag”, flag g表示替换所有非重叠实例，而不仅仅是第一次匹配  </li><li>i表示将文件修改之后的内容不再输入标准输出(默认行为)，而是直接在文件内部修改  </li><li>.表示匹配任意一个字符，*表示这个字符出现0次或多次，用括号括起来表示捕获这个组，\1表示引用之前捕获的第一个组，所以这行命令的意思为将每行行尾出现的apple替换为banana</li></ul></li><li><p><strong>strace</strong><br>跟踪系统调用和信号<br>选项:  </p><ul><li>p: pid，指定进程</li></ul></li><li><p><strong>touch filename</strong><br> 跟踪系统调用和信号</p><ul><li>批量创建文件：touch file{1..5}.txt</li></ul></li><li><p><strong>find exec组合</strong><br>语法:<br>find [path] [arguments] -exec [command] {} ;<br><em>or</em><br>find [path] [arguments] -exec [command] {} +<br> <a href="https://www.myfreax.com/how-to-combine-find-exec-commands/">find exec 命令实例教程</a><br><code>find . -type f -name &#39;*.txt&#39; -exec sh -c &#39;mv &quot;$1&quot; &quot;$&#123;1%.txt&#125;.js&quot;&#39; _ &#123;&#125; \;</code></p><ul><li>解释: ;对;进行转义，表示command的结束，{}存储find命令执行的结果， _是占位符，表示$0 </li><li>find找出所有后缀为txt的文件并使用sh -c启动subshell执行mv命令，将sh传给其的第二个参数(e.g., 1.txt)中的txt删除并替换为.js</li></ul></li><li><p>Inode保存文件的元数据。分别是：Inode编号、文件权限、文件的拥有者的UID、文件所属组的GID、硬链接数、文件的大小、文件的间戳、指向磁盘文件的数据块指针等。其信息如下图所示：<br><img src="/2023/09/30/linux-&-cmake-commands/1652968296373270.webp"><br>通过stat命令可以查看文件的inode信息：<br><img src="/2023/09/30/linux-&-cmake-commands/1.png">  </p></li><li><p><strong>kill</strong><br>   杀死进程<br>   语法: pid&#x2F;job_sepc(作业标识符)<br>   选项:  </p><ul><li>-l 列出所有信号  </li><li>默认发送SIGTERM信号   </li><li>-9&#x2F;KILL发送SIGKILL信号  </li><li>-1&#x2F;HUP发送SIGHUP信号  </li><li>-15&#x2F;TERM发送SIGTERM信号</li></ul></li><li><p><strong>fg</strong><br>将后台进程移动至前台(tty&#x2F;pts)执行<br>语法 : fg [job_spec]</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">运行<span class="hljs-built_in">sleep</span>命令，然后按下ctrl+z。</span><br>sleep 60<br>^Z<br>[1]+  Stopped                 sleep 60<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用<span class="hljs-built_in">fg</span>命令使得作业在前台运行。</span><br>fg %1<br></code></pre></td></tr></table></figure></li><li><p><strong>nm</strong><br>查看库的符号表<br><code>nm ./build/libMyLibExample.a</code>    </p></li><li><p><strong>ulimit</strong><br>控制shell程序的资源,作为临时限制，ulimit 可以作用于通过使用其命令登录的 shell 会话，在会话终止时便结束限制，并不影响于其他 shell 会话 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost ~]# ulimit -a<br>core file size          (blocks, -c) 0           #core文件的最大值为100 blocks。<br>data seg size           (kbytes, -d) unlimited   #进程的数据段可以任意大。<br>scheduling priority             (-e) 0<br>file size               (blocks, -f) unlimited   #文件可以任意大。<br>pending signals                 (-i) 98304       #最多有98304个待处理的信号。<br>max locked memory       (kbytes, -l) 32          #一个任务锁住的物理内存的最大值为32KB。<br>max memory size         (kbytes, -m) unlimited   #一个任务的常驻物理内存的最大值。<br>open files                      (-n) 1024        #一个任务最多可以同时打开1024的文件。<br>pipe size            (512 bytes, -p) 8           #管道的最大空间为4096字节。<br>POSIX message queues     (bytes, -q) 819200      #POSIX的消息队列的最大值为819200字节。<br>real-time priority              (-r) 0<br>stack size              (kbytes, -s) 10240       #进程的栈的最大值为10240字节。<br>cpu time               (seconds, -t) unlimited   #进程使用的CPU时间。<br>max user processes              (-u) 98304       #当前用户同时打开的进程（包括线程）的最大个数为98304。<br>virtual memory          (kbytes, -v) unlimited   #没有限制进程的最大地址空间。<br>file locks                      (-x) unlimited   #所能锁住的文件的最大个数没有限制。<br><br></code></pre></td></tr></table></figure></li><li><p>shell脚本中的特殊变量</p></li></ol><ul><li><code>$$</code> : shell的PID</li><li><code>$0</code> : shell的类型</li><li><code>$_</code> : 表示上一个命令的最后一个参数</li></ul><h2 id="valgrind-调试工具"><a href="#valgrind-调试工具" class="headerlink" title="valgrind 调试工具"></a>valgrind 调试工具</h2><ol><li>valgrind</li></ol><h2 id="系统监测工具"><a href="#系统监测工具" class="headerlink" title="系统监测工具"></a>系统监测工具</h2><ol><li>tcpdump&#x2F;</li><li>host&#x2F;</li><li>telnet&#x2F;</li><li>route&#x2F;</li><li>iptables&#x2F;</li><li>netstat&#x2F;</li><li>nc</li></ol><h2 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h2><h3 id="cmake具体流程"><a href="#cmake具体流程" class="headerlink" title="cmake具体流程"></a>cmake具体流程</h3><ol><li><p>CMakeLists.txt脚本在配置步骤期间执行。该脚本负责定义目标。每个目标表示构建流程的可执行文件、库或其他输出。如果配置步骤成功——也就是说，CMakeLists.txt没有错 误——CMake将使用脚本定义的目标生成构建流程。生成的构建流程类型取决于所使用的生成器类型，在配置步骤期间，根据CMakeLists.txt的内容，可能会发生其他事情。<br>  <em>virsual stdio提供了configure with cmake debugger， 可以设置cmakelists的断点来调试配置过程</em><br><img src="/2023/09/30/linux-&-cmake-commands/cmake-simple-flowchart.png" alt="cmake"></p></li><li><p>vs中可以选择在UI中选择cmake的kit来指定编译器及其配套组件</p></li><li><p>命令行中通过设置cmake的–config选项可以指定编译源文件时是按debug模式还是release模式编译</p></li></ol><h3 id="cmake-commands"><a href="#cmake-commands" class="headerlink" title="cmake commands"></a>cmake commands</h3><ol><li>创建静态库<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(hello_library STATIC<br>    src/Hello.cpp<br>)<br></code></pre></td></tr></table></figure></li></ol><ul><li>hello_library 即为要创建的库文件的名称，该库文件是全局共享的</li></ul><blockquote><p>补充：<br><strong>GCC 命令行创建静态库:</strong><br><code>gcc -c somfile.c -o somefile.o</code><br>使用binutils软件包中的ar工具将目标文件转换为静态库（存档）<br><code>ar rcs libfoo.a somfile.o</code><br>当链接到库时，GCC 会自动从 .a 文件扩展名识别出该库是静态链接的存档。<br><code>gcc ... -lfoo ...</code><br><strong>GCC 命令行创建动态库:</strong><br>使用位置无关代码选项-fPIC将每个源文件编译为目标文件<br><code>gcc ... -c -fPIC some_file.c ...</code><br>从目标文件中链接共享库:<br><code>gcc -shared -o libfoo.so.x.y -Wl,-soname,libfoo.so.x some_file.o ...</code><br>使用的主版本号为 X，次版本号为 Y<br>创建用于soname机制的符号链接结构(软链接):<br><code>ln -s libfoo.so.x.y libfoo.so.x</code><br><code>ln -s libfoo.so.x libfoo.so</code></p></blockquote><ol start="2"><li>链接库<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_link_libraries</span>( hello_binary<br>    PRIVATE<br>        hello_library<br>)<br></code></pre></td></tr></table></figure></li></ol><ul><li>这里的库文件应该是之前使用add_library创建的，若该库是在别的CML下创建的，则应在当前CML使用add_subdirectory(source_dir)引入创建该库的CML所在的目录source_dir</li><li>add_subdirectory(source_dir)其实就是执行了在source_dir下的CML，生成的库文件或可执行文件若没有指定其余参数则会存放在build之后的source_dir目录下</li></ul><ol start="3"><li>添加目标编译所需要的头文件</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_include_directories</span>(hello_headers<br>    PRIVATE <br>        <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span><br>)<br></code></pre></td></tr></table></figure><ul><li>private将头文件目录的作用域限制在当前目标，而不会传递给依赖当前目标的其他目标，这表明其他目标若想使用该头文件，需显式将其添加</li><li>使用该命令之后，在源文件中引入头文件时可以直接使用头文件名，不需要特定加入相对或者绝对地址</li></ul>]]></content>
    
    
    <categories>
      
      <category>GNU/linux</category>
      
      <category>command line</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>cmake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>符合c++14标准的网络和高并发编程</title>
    <link href="/2023/09/19/network-high-concurrency/"/>
    <url>/2023/09/19/network-high-concurrency/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#1-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B">1. 网络编程</a><ul><li><a href="#11-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0">1.1. 字符串处理函数</a></li><li><a href="#12-io%E6%A8%A1%E5%9E%8B">1.2. IO模型</a></li><li><a href="#13-io%E5%A4%8D%E7%94%A8">1.3. IO复用</a></li></ul></li><li><a href="#2-pthread---%E7%AC%A6%E5%90%88posix%E6%A0%87%E5%87%86%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%BA%93">2. pthread - 符合POSIX标准的线程库</a><ul><li><a href="#21-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8F%96%E6%B6%88">2.1. 线程的取消</a></li><li><a href="#22-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8A%A0%E5%85%A5">2.2. 线程的加入</a></li><li><a href="#23-%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E7%BC%96%E7%A8%8B%E7%9A%84%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85">2.3. 一些关于编程的底层知识补充</a></li></ul></li><li><a href="#3-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B">3. 并发编程</a><ul><li><a href="#31-stdthread">3.1. std::thread</a></li><li><a href="#32-stdfuture">3.2. std::future</a></li><li><a href="#33-condition_variable--mutex">3.3. condition_variable &amp; mutex</a></li><li><a href="#34-lock_guard--unique_lock">3.4. lock_guard &amp; unique_lock</a></li></ul></li></ul><h3 id="1-网络编程"><a href="#1-网络编程" class="headerlink" title="1. 网络编程"></a>1. 网络编程</h3><hr><table><thead><tr><th>OSI四层模型</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td>协议</td><td>作用</td><td></td><td></td></tr><tr><td>链路层</td><td>ARP&#x2F;RARP</td><td>ip地址到物理地址的映射</td><td></td><td></td></tr><tr><td>网络层</td><td>IP&#x2F;ICMP</td><td>数据包的选路和转发&#x2F;检查网络连接</td><td></td><td></td></tr><tr><td>传输层</td><td>TCP&#x2F;UDP</td><td>数据的收发以及链路的超时重连</td><td></td><td></td></tr><tr><td>应用层</td><td>DNS(proto)&#x2F;telnet</td><td>域名查询&#x2F;远程连接</td><td></td><td></td></tr></tbody></table><ol><li>ARP协议主要用来向自己所在的网络广播一个ARP请求,该请求包含目标机器的网络地址。此网络上的其他机器都将收到这个请求，但只有被请求的目标机器会回应一个ARP应答，其中包含自己的物理地址<br> <img src="/2023/09/19/network-high-concurrency/arp%E6%8A%A5%E6%96%87.png" alt="arp报文"><br> <img src="/2023/09/19/network-high-concurrency/ethernetframe.png" alt="以太网帧"></li><li>使用telnet在同网络机器中进行远程连接，在一台机器上使用tcpdump进行以太网帧捕捉，捕捉结果显示类型为ARP，ARP报文长度为28字节，被封装在以太网帧中，并且根据以太网帧头部信息长度和ARP报文长度来看，帧总长应为46字节，这里显示42字节表示不考虑尾部4字节的CRC字段（对头部和数据进行循环冗余校验）<br> <img src="/2023/09/19/network-high-concurrency/Snipaste_2023-09-22_22-37-24.png" alt="tcpdump检测结果"></li><li>无状态（ stateless ）是指IP通信双方不同步传输数据的状态信息，因此所有IP数据报的发送、传输和接收都是相互独立、没有上下文关系的。这种服务最大的缺点是无法处理乱序和重复的 IP 数据报 。 比如发送端发送出的第 N 个 IP 数据报可能比第 N + 1个IP数据报后到</li><li>计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。在计算机内部，小端序被广泛应用于现代 CPU 内部存储数据；而在其他场景，比如网络传输和文件存储则使用大端序。<br><img src="/2023/09/19/network-high-concurrency/v2-233887068992518bb4eec56de043d1b2_r.jpg" alt="大端序和小端序"></li><li>tcp&#x2F;ip新感悟<ul><li>tcp通信双方在连接初始化，即发送同步报文段中要确定MSS及扩大窗口因子的大小，这样可以有效防止ip模块进行分片处理，同步报文段显示的接收窗口win值都是真实的win值，不需要乘以2的窗口因子次幂</li><li>http和udp都是无状态协议，即每个http请求之间没有上下文关系，解决办法为设置cookie，服务器向客户端发送cookie，客户端每次请求时都会带上cookie（通过HTTP头部字段cookie），这样服务器就可以区别不同客户</li><li>ip模块通过接收和发送ip数据报输入队列和输出队列与网络驱动程序交互</li><li>半关闭状态指的是某方将socket的写端关闭，表示数据已经发送完毕，此时socket发送缓冲区中的数据全部被刷新，接收方可以使用read系统调用返回0来检测对方是否关闭了写操作</li><li>tcpdump中显示的seq值有两个，被冒号分隔，冒号前是这次的seq值，冒号后是发送数据之后的seq值，ack值是其收到的tcp报文段序号值<strong>加1</strong></li><li>tcp拥塞控制：<ul><li>cwnd是由发送端引入的称为拥塞窗口的变量，假设网络状况良好，慢启动过程中每次rtt时间内都会连续发送cwnd&#x2F;smss个报文段，并且也会接收cwnd&#x2F;smss个ack，那么cwnd在一次rtt内就翻倍，这也是慢启动过程中cwnd呈指数型增长的原因</li><li>发送窗口swnd其实是由cwnd和接收的ack所显示的对方的接收窗口rwnd二者中的最小值决定的，昭示了下次接收到新ack前可以往网络中写入多少个tcp报文段。</li><li>快速重传个人理解为将ssthresh调整为max(未确认的字节数&#x2F;2， 2*smss), 再调整cwnd为ssthresh加3倍的smss, 可见此时cwnd是远大于ssthresh的(但是ssthresh的大小和原来相比呢？？)，之后接收到新数据的ack后就将cwnd快速恢复恢复为ssthresh，进入拥塞避免阶段</li></ul></li></ul></li></ol><h4 id="1-1-字符串处理函数"><a href="#1-1-字符串处理函数" class="headerlink" title="1.1. 字符串处理函数"></a>1.1. 字符串处理函数</h4><ol><li>strpbrk(char* s1, char* s2) 指向str1中任何属于str2字符的第一个出现位置的指针，如果在终止的空字符之前在str1中找不到str2的任何字符，则返回空指针。如果在str1中不存在str2的任何字符，则返回空指针。</li><li><strong>strcasecmp</strong>(char* s1, char* s2) 和 <strong>strcmp</strong> 相似，但strcasecmp不区分大小写，<strong>strcasencmp</strong> 和 <strong>strncmp</strong> 类似</li></ol><h4 id="1-2-IO模型"><a href="#1-2-IO模型" class="headerlink" title="1.2. IO模型"></a>1.2. IO模型</h4><p>通过fcntl设置文件描述符属性为O_NONBLOCK，这样的文件描述符被称为非阻塞IO，当accept，recv，send等系统调用处理非阻塞IO时，会立即返回，若事件没有发生，则会返回-1并设置errno为EAGAIN或EWOULDBLOCK（其实二者相同），对connect而言则是EINPORCESS</p><h4 id="1-3-IO复用"><a href="#1-3-IO复用" class="headerlink" title="1.3. IO复用"></a>1.3. IO复用</h4><p>IO复用可以使程序同时监听多个文件描述符，IO复用函数可以向内核注册文件描述符及其关联的可读，可写，异常事件，并返回就绪事件的数量（通知进程事件已经就绪）</p><ol><li><p>epoll和select以及poll的区别在于epoll对应一组函数调用，如epoll_ctl,epoll_wait，并将就绪事件重新赋值给一个新event数组，这样节省轮询事件就绪的时间</p></li><li><p>epoll，select，poll都会因为内核收到信号而返回-1并设置errno为EINTR</p></li><li><p>epoll两种工作模式LT,ET在处理可读事件的区别在于</p><ul><li>LT：如果此时缓存区没有可读数据，则epoll_wait不会返回EPOLLIN，如果此时缓冲区有可读数据，则epoll_wait会持续返回EPOLLIN</li><li>ET：如果此时缓存区没有可读数据，则epoll_wait不会返回EPOLLIN，如果此时缓冲区有可读数据，则epoll_wait会返回一次EPOLLIN<br>可通过设置evnets为EPOLL_ET来显式设置工作模式为EPOLL_ET</li><li>具体来说，设置ET之后，在epoll_wait()期间，若socket&#x2F;pipe对应的缓冲区的数据发生了变化，则会通知事件发生，若没有变化，则会一直阻塞</li><li>比LT高效的点在于epoll不会通过轮询文件描述符，观察缓冲区是否还有数据来通知事件是否发生，而是当数据到来时通过回调函数来通知事件发生</li><li>当多块数据同时到来时，比如tcp的接收缓冲区小于发送的数据量，此时也会多次通知事件发生</li><li>ET对应的文件描述符应当是非阻塞的，使用EPOLLET标志的应用程序应该使用非阻塞文件描述符，以避免阻塞读或写使正在处理多个文件描述符的任务饥饿。使</li><li>为<strong>EPOLLOUT</strong>设置ET的含义：如果溢出套接字发送缓冲区，则会从send或write获得EAGAIN。在这种情况下, 开始等待输出变得可能（内核排空套接字发送缓冲区，从而为发送更多数据腾出空间），方法是包含EPOLLOUT。<blockquote><p>如果多个线程（或者进程，如果子进程通过fork(2)继承了epoll文件描述符）在等待同一个epoll文件描述符上的epoll_wait(2)时被阻塞，并且兴趣列表中标记为边缘触发（EPOLLET）通知的文件描述符准备好了，只有一个线程（或进程）会从epoll_wait(2)中唤醒。这在某些情况下提供了一个有用的优化，可以避免”惊群”唤醒。</p></blockquote></li></ul></li><li><p>由于ET工作模式仍会导致某个事件被触发多次，使得多线程可能会处理同个fd，从而避免许多竞态条件，EPOLLONESHOT使得某个时刻只可能触发fd注册的一个可读，可写，异常事件，并且该事件只能触发一次</p><ul><li>可通过epoll_ctl来重新设置EPOLLONESHOT来重新触发新的可读事件（通过设置flag为EPOLL_CTL_MOD）</li><li>监听fd不应该设为EPOLLONESHOT，不然只能某个时刻处理一个客户连接（新来的连接不会触发新事件）</li></ul></li><li><p>多线程使用pthread_exit(NULL)来退出线程不是<strong>异步信号安全的</strong>，其发出的信号可以中断例如epoll_wait()等阻塞函数 </p></li><li><p>对非阻塞IO进行connect()系统调用，可能会立即返回-1并设置errno为EAGAIN（UNIX本地协议族socket）或EINPROGRESS表示连接已经开始但未完全建立好，这时使用select或poll监听sockfd上的写事件（非阻塞connect连接成功或者因为超时失败时会触发写就绪事件）, 超时失败是指客户端同步报文段发出后收不到ack，在本地arch环境下，重连次数为6，也就是127（1+2+4+8+16+32+64）s, 不论是失败或者成功，select都会返回写就绪，此时需要getsockopt中设置SO_ERROR选项来查看socket上的错误事件，对应测试cpp文件为non_blockconnect.cc<br><a href="http://cr.yp.to/docs/connect.html">Dan_Bernstein对于非阻塞socket连接的理解和思考</a></p></li></ol><h3 id="2-pthread-符合POSIX标准的线程库"><a href="#2-pthread-符合POSIX标准的线程库" class="headerlink" title="2. pthread - 符合POSIX标准的线程库"></a>2. pthread - 符合POSIX标准的线程库</h3><h4 id="2-1-线程的取消"><a href="#2-1-线程的取消" class="headerlink" title="2.1. 线程的取消"></a>2.1. 线程的取消</h4><ol><li>如果想在线程执行时取消该线程。可以使用pthread_cancel(thread)来完成此操作,该函数向指定线程发出一个取消请求，。但是，请记住需要启用 pthread 取消支持。此外，还有取消时的清理代码。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">thread_cleanup_push</span>(my_thread_cleanup_handler, resources);<br><span class="hljs-built_in">pthread_setcancelstate</span>(PTHREAD_CANCEL_ENABLE, <span class="hljs-number">0</span>);<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">my_thread_cleanup_handler</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// free</span><br>  <span class="hljs-comment">// close, fclose</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>一个线程的取消类型，由**pthread_setcanceltype(3)**确定，可以是异步的(PTHREAD_CANCEL_ASYNCHRONOUS)或延迟的(PTHREAD_CANCEL_DEFERRED)（新线程的默认值）。异步可取消性意味着线程可以随时被取消（通常是立即，但系统不保证这一点）。延迟可取消性意味着取消将被延迟，直到线程下次调用一个是取消点(cancel_point)的函数。</li><li>线程的可取消状态由**pthread_setcancelstate(3)**确定，可以启用（新线程的默认值）或禁用。如果线程已禁用取消，则取消请求将保持排队状态，直到线程启用取消。如果线程已启用取消，则其可取消性类型确定何时发生取消。</li><li>pthread_cleanup_push(void (*routine)(void *), void *arg);<br>void pthread_cleanup_pop(int execute);</li></ol><ul><li><p>这些函数操作调用线程的线程取消清理处理程序堆栈。清理处理程序是在取消线程时自动执行的函数。</p></li><li><p>pthread_cleanup_push()函数将routine推送到清理处理程序堆栈的顶部。当routine稍后被调用时，它将被给予arg作为其参数。</p></li><li><p>pthread_cleanup_pop()函数从清理处理程序堆栈的顶部移除routine，并在execute为非零时可选择执行它。</p></li><li><p>在以下情况下，取消清理处理程序将从堆栈中弹出并执行：</p><ul><li><p>当线程被取消时，所有堆栈清理处理程序都会被弹出并按照它们被推入堆栈的顺序相反执行。</p></li><li><p>当线程通过调用pthread_exit(3)终止时，所有清理处理程序都会按照前面描述的方式执行。（如果线程通过从线程开始函数返回来终止，则不会调用清理处理程序。）</p></li><li><p>当线程调用pthread_cleanup_pop()并带有非零的execute参数时，最顶部的清理处理程序将被弹出并执行。</p></li></ul></li></ul><blockquote><p>POSIX.1 允许 pthread_cleanup_push() 和 pthread_cleanup_pop() 作为宏实现，它们分别扩展为包含 ‘{‘ 和 ‘}’ 的文本。因此，调用者必须确保在同一函数中、在相同的词法嵌套级别内调用这些函数。（换句话说，仅在执行指定代码段期间才建立清理处理程序。）</p></blockquote><ol start="5"><li>pthread_exit(void* retval) vs phread_cancel(tid)<ul><li>pthread_cancel()函数将请求取消线程。目标线程的取消状态和类型决定何时取消生效。当取消被执行时，将调用线程的取消清理处理程序。当最后一个取消清理处理程序返回时，将为线程调用线程特定数据(Thread_specific data)析构函数。当最后一个析构函数返回时，线程将被终止。目标线程中的取消处理与从pthread_cancel()返回的调用线程异步运行</li><li>由于许多系统调用在接收信号时返回并将errno设置为EINTR，因此很容易捕获此情况，并通过pthread_exit()使线程在此条件下干净地结束自身<br>就线程资源清理的情况而言，二者并无本质区别, 都要通过pthread_cleanup_push设置的函数来清理动态分配资源</li></ul></li></ol><h4 id="2-2-线程的加入"><a href="#2-2-线程的加入" class="headerlink" title="2.2. 线程的加入"></a>2.2. 线程的加入</h4><p>int pthread_join(pthread_t thread, void **retval)</p><ol><li>如果 retval 不为 NULL，则 pthread_join() 将目标线程的退出状态（即目标线程提供给 pthread_exit(3) 的值）复制到 retval 指向的位置。如果目标线程被取消，则在 retval 指向的位置放置 PTHREAD_CANCELED。</li><li>成功的话返回0，失败返回一个errno(例如因中断返回EINTR)</li></ol><h4 id="2-3-一些关于编程的底层知识补充"><a href="#2-3-一些关于编程的底层知识补充" class="headerlink" title="2.3. 一些关于编程的底层知识补充"></a>2.3. 一些关于编程的底层知识补充</h4><ol><li>函数的可重入性(reentrancy)<br>函数的线程安全性，保证多个线程同时执行一个函数不会出现竞态条件，同时在单处理器系统上当该函数被中断（可能是信号导致的）并被重新执行时可以安全执行</li><li>函数的幂等性(idempotence)<br>函数在被多次执行后可以产出同一结果</li></ol><h3 id="3-并发编程"><a href="#3-并发编程" class="headerlink" title="3. 并发编程"></a>3. 并发编程</h3><h4 id="3-1-std-thread"><a href="#3-1-std-thread" class="headerlink" title="3.1. std::thread"></a>3.1. std::thread</h4><ol><li>thread构造时会将可调用函数和传入参数完美转发并根据左值右值选择拷贝或移动构造至一个tuple中，返回invoke_result&lt;decay<F>::type, decay<Args>::type…&gt;::type，也就是F调用去掉引用和cv限定之后的实参之后返回的类型，调用时会将tuple中的数据使用<strong>std::move</strong>方法转为右值进行调用，所以对于左值引用类型的数据无法正常调用，编译时thread会调用静态断言来报错<em>不能将左值引用绑定到右值</em>之类的消息</li></ol><blockquote><p>invoke_result 是 result_of 的 更进版本，<del>具体内容见cppreference</del>， 这里加入几个type_traits的知识点：首先decltype(function)不能直接用来调用，可以在后方加入&amp;来表示对函数的引用:<br><code>int fn(int) &#123;return int();&#125; </code><br><code>typedef std::result_of&lt;decltype(fn)&amp;(int)&gt;::type A; </code><br>其次常见的type_traits有</p><ul><li>iterator_traits<T>::type</li><li>remove_reference<T>::type</li><li>decay<T>::type</li><li>函数declval<T>()（返回右值引用，此函数只能在未求值的操作数（比如 sizeof 和 decltype 的操作数）中使用。）</li><li>is_constructible&lt;T,args…&gt;::value（args是否能构造T）等返回0或1来表示类型判断的类也属于type_traits, </li><li>plus<T>:构建一个仿函数，使用operator()(T&amp; lhs, T&amp; rhs)可以计算任意两个T类型对象的和</li></ul></blockquote><ul><li>补充两个重要的工具类：</li></ul><p>  <code>typedef std::integral_constant&lt;   bool, true&gt; true_type; typedef std::integral_constant&lt;   bool, false&gt; false_type;</code></p><ol start="2"><li><p>不只是thread，bind以及async都会在创建的对象中构造传入实参另一份数据，所以如果函数形参为引用类型，使用std::ref()来构造reference_wrapper函数对象是一个明智的选择</p></li><li><p>thread在析构时若是<strong>可结合的</strong>，比如没有显式join(主线程会阻塞直到thread对应的底层线程返回)或detach(底层软件线程分离)或者移动，则会调用std::terminate终止程序</p></li><li><p>thread作为软件线程的句柄可调用native_handle来返回tid，之后可以通过其他方法来设置线程优先级和调度策略，<strong>这是future做不到的</strong></p></li><li><p>为了防止线程终止，可以构造RAII类型对象，在析构时通过构造实参指定的join或者detach来指定析构方法</p></li><li><p>获取传统posix标准底层pthread的tid的方式为调用thread对象的native_handler, 而在c++层面上获取线程的ID标识符，本线程应该调用std::this_thread::get_id()，其余线程应该调用t.get_id(), t为std::thread对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadRAII</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">DtorAction</span> &#123; join, detach &#125;;         <span class="hljs-comment">//跟之前一样</span><br><br>    <span class="hljs-built_in">ThreadRAII</span>(std::thread&amp;&amp; t, DtorAction a)       <span class="hljs-comment">//跟之前一样</span><br>    : <span class="hljs-built_in">action</span>(a), <span class="hljs-built_in">t</span>(std::<span class="hljs-built_in">move</span>(t)) &#123;&#125; <span class="hljs-comment">//std::thread对象可能会在初始化结束后就立即执行函数了，所以在最后声明是一个好习惯</span><br><br>    ~<span class="hljs-built_in">ThreadRAII</span>()<br>    &#123;<br>        …                                           <span class="hljs-comment">//跟之前一样</span><br>    &#125;<br><br>    <span class="hljs-built_in">ThreadRAII</span>(ThreadRAII&amp;&amp;) = <span class="hljs-keyword">default</span>;             <span class="hljs-comment">//支持移动</span><br>    ThreadRAII&amp; <span class="hljs-keyword">operator</span>=(ThreadRAII&amp;&amp;) = <span class="hljs-keyword">default</span>;<br><br>    <span class="hljs-function">std::thread&amp; <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> t; &#125;                <span class="hljs-comment">//跟之前一样</span><br><br><span class="hljs-keyword">private</span>: <span class="hljs-comment">// as before</span><br>    DtorAction action;<br>    std::thread t;<br>&#125;;<br><br></code></pre></td></tr></table></figure><blockquote><p>按理来说当显式生成析构函数时，编译器不会再主动生成移动构造和移动赋值函数，但当对象是可以逐成员移动时，我们可以显式default声明移动函数来保证移动操作是可以被执行的  </p></blockquote></li><li><p>为了防止线程在开始后被修改优先级，可以在创建线程时将方法设为wait函数，将线程挂起</p></li></ol><h4 id="3-2-std-future"><a href="#3-2-std-future" class="headerlink" title="3.2. std::future"></a>3.2. std::future</h4><ol><li>与thread不同，在使用默认策略启动时，不一定会使用异步执行，这种调用方式将线程管理的职责转交给C++标准库的开发者。举个例子，这种调用方式会减少抛出资源超额异常的可能性</li><li>std::launch::deferred启动策略意味着f仅当在std::async返回的future上调用get或者wait时才执行。这表示f推迟到存在这样的调用时才执行</li><li>默认启动策略的调度灵活性导致使用thread_local变量比较麻烦，因为这意味着如果f读写了线程本地存储（thread-local storage，TLS），不可能预测到哪个线程的变量被访问</li></ol><ul><li>可以使用 <code>fut.wait_for(0s) == std::future_status::deferred</code> 检查函数是否被延时执行</li><li>在检查异步执行的future是否完成执行时，可以检查<code>fut.wait_for(100ms) == std::future_status::ready</code></li></ul><ol start="4"><li>future是通信信道的一端，被调用者通过该信道将结果发送给调用者。被调用者（通常是异步执行）将计算结果写入通信信道中（通常通过std::promise对象），调用者使用future读取结果, 除了这种普通用途外还可以将promise模板实参设为void，用来当作<strong>条件变量</strong>通知future对象，future所在线程调用wait方法将会阻塞直到结果返回，这种方法好处在于不再需要互斥锁，条件变量，或者原子变量，并且可以用来设置线程优先级，使得线程在创建时不会自动运行，处于挂起状态，坏处在于通道的值只能设置一次，线程也只能被挂起一次。<br>  <img src="/2023/09/19/network-high-concurrency/item38_fig1.png" alt="future信道"></li><li>因为与被调用者关联的对象和与调用者关联的对象都不适合存储这个结果，所以调用结果必须存储在两者之外的位置。此位置称为共享状态（shared state）。共享状态通常是基于堆的对象，一般来说对于future对象拥有这个共享状态的控制权，或者说引用了共享状态，析构时引用该状态的future会自动阻塞并且等待任务完成</li><li>future不能被拷贝，但他却可以用来构造shared_future(通过成员函数share())，之后转交共享状态的控制权，shared_future在并发访问时可以用来为每个线程构造副本来共享共享状态的拥有权，设置std::promise::set_value()可以在多线程使用wait来唤起多个线程<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::promise&lt;<span class="hljs-type">void</span>&gt; p;                   <span class="hljs-comment">//跟之前一样</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">detect</span><span class="hljs-params">()</span>                           <span class="hljs-comment">//现在针对多个反映线程</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> sf = p.<span class="hljs-built_in">get_future</span>().<span class="hljs-built_in">share</span>();   <span class="hljs-comment">//sf的类型是std::shared_future&lt;void&gt;</span><br>    std::vector&lt;std::thread&gt; vt;        <span class="hljs-comment">//反应线程容器</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; threadsToRun; ++i) &#123;<br>        vt.<span class="hljs-built_in">emplace_back</span>([sf]&#123; sf.<span class="hljs-built_in">wait</span>();    <span class="hljs-comment">//在sf的局部副本上wait；</span><br>                              <span class="hljs-built_in">react</span>(); &#125;);  <span class="hljs-comment">//emplace_back见条款42</span><br>    &#125;<br>    …                                   <span class="hljs-comment">//如果这个“…”抛出异常，detect挂起！</span><br>    p.<span class="hljs-built_in">set_value</span>();                      <span class="hljs-comment">//所有线程解除挂起</span><br>    …<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; t : vt) &#123;                <span class="hljs-comment">//使所有线程不可结合；</span><br>        t.<span class="hljs-built_in">join</span>();                       <span class="hljs-comment">//“auto&amp;”见条款2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="3-3-condition-variable-mutex"><a href="#3-3-condition-variable-mutex" class="headerlink" title="3.3. condition_variable &amp; mutex"></a>3.3. condition_variable &amp; mutex</h4><ol><li>cv.Wait(lock<which is basically unique_lock>, bool function)会导致当前线程阻塞，直到条件变量被通知或发生假唤醒，或者循环直到满足某个谓词</li></ol><h4 id="3-4-lock-guard-unique-lock"><a href="#3-4-lock-guard-unique-lock" class="headerlink" title="3.4. lock_guard &amp; unique_lock"></a>3.4. lock_guard &amp; unique_lock</h4><ol><li>lock_guard自动加锁解锁，在函数异常等情况下函数内部直接返回也会执行对锁的析构，需要注意对锁的占用时间，为了手动释放锁可以在lock_guard周围加入花括号即可</li><li>wait function causes the current thread to block until the condition variable is notified or a spurious wakeup occurs, optionally looping until some predicate is satisfied</li></ol>]]></content>
    
    
    <categories>
      
      <category>cpp related</category>
      
      <category>GNU/linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>POSIX socket</tag>
      
      <tag>c11/14 thread/future</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp学习上遇到的问题</title>
    <link href="/2023/08/25/houjiecpp/"/>
    <url>/2023/08/25/houjiecpp/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#1-20230829">1. 2023&#x2F;08&#x2F;29</a></li><li><a href="#2-20230829">2. 2023&#x2F;08&#x2F;29</a><ul><li><a href="#21-unicode">2.1. unicode</a></li><li><a href="#22-%E9%9D%9E%E7%B1%BB%E5%9E%8B%E5%BD%A2%E5%8F%82%E7%9A%84%E5%B1%80%E9%99%90">2.2. 非类型形参的局限：</a></li><li><a href="#23-%E9%9D%9E%E7%B1%BB%E5%9E%8B%E5%AE%9E%E5%8F%82%E7%9A%84%E5%B1%80%E9%99%90">2.3. 非类型实参的局限：</a><ul><li><a href="#231-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%B8%AD%E6%A8%A1%E6%9D%BF%E5%AE%9E%E5%8F%82%E7%9A%84%E6%8E%A8%E5%AF%BC">2.3.1. 函数模板中模板实参的推导</a></li></ul></li><li><a href="#24-%E7%BC%96%E8%AF%91%E6%97%B6%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F">2.4. 编译时常量表达式</a></li><li><a href="#25-%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2">2.5. 隐式转换</a></li><li><a href="#26-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">2.6. 设计模式</a></li><li><a href="#27-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">2.7. 智能指针</a></li><li><a href="#28-const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">2.8. const成员函数</a></li><li><a href="#29-%E5%8F%B3%E5%80%BC">2.9. 右值</a></li><li><a href="#210-%E6%A8%A1%E6%9D%BF%E6%9D%82%E7%B1%BB">2.10. 模板杂类</a></li><li><a href="#211-lambda">2.11. lambda</a></li><li><a href="#212-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88">2.12. 成员函数指针</a></li><li><a href="#213-%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E6%8C%87%E9%92%88">2.13. 数据成员指针</a></li><li><a href="#214-%E8%99%9A%E5%87%BD%E6%95%B0">2.14. 虚函数</a><ul><li><a href="#2141-%E4%BB%8E%E6%B1%87%E7%BC%96%E5%B1%82%E9%9D%A2%E7%90%86%E8%A7%A3%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0">2.14.1. 从汇编层面理解虚函数的实现</a></li><li><a href="#2142-%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0">2.14.2. 虚析构函数</a></li></ul></li><li><a href="#215-%E8%99%9A%E5%9F%BA%E7%B1%BB">2.15. 虚基类</a></li></ul></li><li><a href="#3-202391">3. 2023&#x2F;9&#x2F;1</a><ul><li><a href="#31-stdbind">3.1. std::bind</a></li><li><a href="#32-%E5%85%B3%E4%BA%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95%E8%A1%A8%E8%BF%B0%E4%B8%8A%E5%8F%AF%E8%83%BD%E6%9C%89%E7%BA%B0%E6%BC%8F%E4%BD%86%E6%A0%B9%E6%8D%AE%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%9D%A5%E7%9C%8B%E5%BA%94%E8%AF%A5%E6%98%AF%E6%AD%A3%E7%A1%AE%E7%9A%84">3.2. 关于初始化的一些想法，表述上可能有纰漏，但根据代码执行来看应该是正确的</a><ul><li><a href="#321-%E5%80%BC%E5%88%9D%E5%A7%8B%E5%8C%96">3.2.1. 值初始化</a></li><li><a href="#322-%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96">3.2.2. 默认初始化</a></li><li><a href="#323-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">3.2.3. 静态成员的初始化</a><ul><li><a href="#3231-2023111-%E6%9B%B4%E6%96%B0%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96">3.2.3.1. 2023&#x2F;11&#x2F;1 更新动态初始化</a></li></ul></li></ul></li><li><a href="#33-internal-linkage--external-linkage">3.3. internal linkage &amp;&amp; external linkage</a></li><li><a href="#34-cc99ansi-c-%E5%92%8C-gnu-c-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB">3.4. C、C99、ANSI C 和 GNU C 之间的区别</a></li></ul></li><li><a href="#4-%E6%9C%AA%E5%AE%8C%E6%88%90%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1">4. 未完成的学习任务</a></li></ul><h1 id="1-2023-08-29"><a href="#1-2023-08-29" class="headerlink" title="1. 2023&#x2F;08&#x2F;29"></a>1. 2023&#x2F;08&#x2F;29</h1><ul><li><p>析构函数和复制构造函数不能是模板。若声明了可用复制构造函数的类型签名实例化的模板构造函数，则替而使用隐式声明的复制构造函数。</p></li><li><p>成员函数模板不能为虚，且派生类中的成员函数模板不能覆盖来自基类的虚成员函数。</p></li><li><p>重载规则规定当模板实例化函数和非模板函数（或者称为“正常”函数）匹配优先级相当时，优先使用“正常”函数。</p></li></ul><hr><ul><li><input checked="" disabled="" type="checkbox"> 函数模板重载</li><li>重载运算符为成员函数和友元函数时关键的区别在于成员函数具有this指针，而友元函数没有this指针。</li></ul><h1 id="2-2023-08-29"><a href="#2-2023-08-29" class="headerlink" title="2. 2023&#x2F;08&#x2F;29"></a>2. 2023&#x2F;08&#x2F;29</h1><h2 id="2-1-unicode"><a href="#2-1-unicode" class="headerlink" title="2.1. unicode"></a>2.1. unicode</h2><ol><li><p>字符集定义了字符和数字(一般用16进制表示，又名<strong>码点</strong>)的对应关系，为每个字符分配了唯一的编号。可以将字符集理解成一个很大的表格，它列出了所有字符和数字的对应关系，<br>计算机显示文字或者存储文字，就是一个查表的过程。</p></li><li><p>而字符编码规定了如何将字符的编号存储到计算机中。如果使用了类似 GB2312 和 GBK 的变长存储方案（不同的字符占用的字节数不一样），那么为了区分一个字符，到底使用了几个字节，就不能将字符的编号直接存储到计算机中，字符编号在存储之前必须要经过转换，在读取时还要再逆向转换一次，这套转换方案就叫做字符编码</p></li></ol><ul><li>字面常量(literal constant)即无需定义可以直接写出来的量。字面常量的值一望便知，但是他的数据类型往往不能被准确分辨（尤其是使用auto时）。</li><li>编译期可知的值“享有特权”，它们可能被存放到只读存储空间中。<blockquote><p>这里的编码指的是字符对应的数如何映射为二进制数，utf-8中一个数字可能映射为1-4字节的二进制编码，utf-32是所有的数都映射为4字节，utf-16则是用2或4字节来实现映射，宽字符wchar_t则是根据实现定义，它是32位，在Linux和许多其他非Windows系统上保存 UTF-32，但在 Windows上是16位，保存 UTF-16<strong>代码单元</strong>。<br>代码单元是字符编码系统（例如 UTF-8 或 UTF-16）使用的基本组件。字符编码系统使用一个或多个代码单元对 Unicode代码点进行编码。</p></blockquote></li></ul><h2 id="2-2-非类型形参的局限："><a href="#2-2-非类型形参的局限：" class="headerlink" title="2.2. 非类型形参的局限："></a>2.2. 非类型形参的局限：</h2><ol><li>浮点数不可以作为非类型形参，包括float，double。具体原因可能是历史因素，也许未来C++会支持浮点数；</li><li>类不可以作为非类型形参；</li><li>字符串不可以作为非类型形参；</li><li>整形，可转化为整形的类型都可以作为形参，比如int，char，long，unsigned，bool，short（enum声明的内部数据可以作为实参传递给int，但是一般不能当形参）；</li><li>指向对象或函数的指针与引用（左值引用）可以作为形参。</li><li>this is <a href="https://github.com/" title="Optional Title Here">an example</a></li></ol><h2 id="2-3-非类型实参的局限："><a href="#2-3-非类型实参的局限：" class="headerlink" title="2.3. 非类型实参的局限："></a>2.3. 非类型实参的局限：</h2><ol><li>实参必须是编译时常量表达式，不能使用非const的局部变量，局部对象地址及动态对象；</li><li>非const的全局指针，全局对象&#x2F;全局变量（下面可能有个特例）都不是常量表达式；</li><li>由于形参的已经做了限定，字符串，浮点型即使是常量表达式也不可以作为非类型实参 ；</li><li>当模板非类型形参为对象指针或引用时，则对于实参而言他们指向的对象不能是字符串字面值、临时量或者数据成员或者其他子对象。<ul><li>这些限制在每个的C++版本中有所放送，额外的限制：<ol><li>C++11前，该对象必须有外部链接（external linkage）</li><li>C++14前，该对象必须有外部链接或者内部链接<blockquote><p>备注：常量表达式基本上是字面值以及const修饰的变量</p></blockquote></li></ol></li></ul></li><li>紧接上条，如果非类型形参类型为对象指针，则实参必须传入完整对象的地址，<em>直接用取地址符取对象地址</em>，不能是指向该对象的指针</li></ol><h3 id="2-3-1-函数模板中模板实参的推导"><a href="#2-3-1-函数模板中模板实参的推导" class="headerlink" title="2.3.1. 函数模板中模板实参的推导"></a>2.3.1. 函数模板中模板实参的推导</h3><ol><li>如果模板函数中数组类型形参(<strong>不是模板列表中的模板形参</strong>)不是引用传递而是值传递，数组会自动降一维，成为一个指向一维数组的指针<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T)</span></span>;<br> <br><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>];<br><span class="hljs-built_in">f</span>(a); <span class="hljs-comment">// P = T, A = int[3], adjusted to int*: deduced T = int*</span><br></code></pre></td></tr></table></figure></li><li>数组在做模板函数的实参时，若模板函数形参不是引用或指向数组的指针(列如二维数组退化为指向一维数组的指针)，则不会进行模板实参推导<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">size_t</span> w, <span class="hljs-type">size_t</span> h&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">double</span> (&amp;s)[w][h])</span></span>&#123;cout&lt;&lt;s[<span class="hljs-number">0</span>]&lt;&lt;endl;&#125; <span class="hljs-comment">//若去掉引用，则w不会被正确推导，但h可以，因为此时退化为一维数组指针</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="2-4-编译时常量表达式"><a href="#2-4-编译时常量表达式" class="headerlink" title="2.4. 编译时常量表达式"></a>2.4. 编译时常量表达式</h2><ul><li>整形常量为如果被常量表达式初始化则为常量表达式 ，也可以用于初始化其他常量表达式，其他类型目前未知</li><li>constexpr 所表示的对象为const，被放置在只读内存中，是在编译期就可以被处理识别的值, 并且对象一定要被正确初始化</li><li>constexpr 所表示的函数的参数和返回值都应为字面值或编译期常量（该常量也应被加上constexpr说明符），当多个不可知量调用constexpr函数时，该函数所表现出的形式为普通函数，所以constexpr的返回值不一定是const</li><li>在C++11中，除了void外的所有内置类型，以及一些用户定义类型都可以是字面值类型，因为构造函数和其他成员函数可能是constexpr(<strong>c++14</strong>constexpr函数可以返回void)</li><li>Point的构造函数可被声明为constexpr，因为如果传入的参数在编译期可知，Point的数据成员也能在编译器可知。因此这样初始化的Point就能为constexpr </li><li>声明为constexpr的<strong>静态</strong>成员对象是<strong>内联</strong>的，在odr-use时可以不用在类外定义，lambda表达式中被odr-use的变量一定要被捕获，被捕获的变量不论是不是constexpr都不能用于常量表达式</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">magic</span> &#123;<br>  <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> number = <span class="hljs-number">42</span>; <span class="hljs-comment">//c++17引入内联变量的概念，此处使用constexpr默认为内联，</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  std::vector&lt;<span class="hljs-type">int</span>&gt; v;<br>  <span class="hljs-comment">// 调用 push_back(const T&amp;)</span><br>  v.<span class="hljs-built_in">push_back</span>(magic::number);<br>  std::cout &lt;&lt; v[<span class="hljs-number">0</span>] &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在函数体内定义的constexpr变量不能用于初始化constexpr引用，constexpr引用必须被静态存储或<em>线程局部</em>常量表达式初始化（也称左值核心常量表达式）</li><li>constexpr的变量也是在运行期给予地址的，所以取地址不是常量表达式</li><li>constexpr变量模板，之前我们需要用类静态数据成员来表达的东西，使用变量模板可以更简洁地表达。constexpr 很合适用在变量模板里，表达一个和某个类型相关的编译期常量。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">inline</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span><br>  is_trivially_destructible_v =<br>    is_trivially_destructible&lt;<br>      T&gt;::value;  <span class="hljs-comment">//判断类是否能平凡析构，指是否不调用析构函数也能正确回收资源</span><br><br></code></pre></td></tr></table></figure></li></ul><blockquote><p>个人对于常量表达式的理解目前仍旧比较浅显，cppreference关于constexpr的叙述看的好像明白又好像完全不懂…</p></blockquote><h2 id="2-5-隐式转换"><a href="#2-5-隐式转换" class="headerlink" title="2.5. 隐式转换"></a>2.5. 隐式转换</h2><ul><li>常见的隐式转换有<ol><li>整形之间以及整形浮点数（算术类型）</li><li>nullptr和其他类型之间的转换</li><li>函数到函数指针的转换</li><li>up-casting</li></ol></li><li>一个隐式类型转换序列包括一个初始标准转换序列、一个用户定义转换序列、一个第二标准转换序列,也就是说不存在什么两步转换问题，本身转换序列最少可以转换1次，最多可以三次。两次转换当然没问题了。唯一会触发问题的是出现了两次用户定义转换，因为隐式转换序列里只允许一次用户定义转换，语言标准也规定了不允许出现多余一次的用户定义转换：</li></ul><hr><h2 id="2-6-设计模式"><a href="#2-6-设计模式" class="headerlink" title="2.6. 设计模式"></a>2.6. 设计模式</h2><ul><li><p>观察者模式是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。</p><p><img src="/2023/08/25/houjiecpp/structure.png" alt="observer示例"></p></li><li><p>奇怪的重复模板模式 （CRTP ）</p></li><li></li></ul><h2 id="2-7-智能指针"><a href="#2-7-智能指针" class="headerlink" title="2.7. 智能指针"></a>2.7. 智能指针</h2><ul><li>shared_ptr的析构会将引用计数减一，但lambda闭包中的ptr还持有一个引用,引用计数不会变为0</li></ul><h2 id="2-8-const成员函数"><a href="#2-8-const成员函数" class="headerlink" title="2.8. const成员函数"></a>2.8. const成员函数</h2><p> const成员函数即表示不会修改类的非mutable数据成员，const修饰成员函数的意义就在于c++规定const类对象在调用非const成员函数时会报错，当成员函数的const和非const版本同时存在时，非const对象只会调用非const成员函数，const对象只会调用const成员函数</p><h2 id="2-9-右值"><a href="#2-9-右值" class="headerlink" title="2.9. 右值"></a>2.9. 右值</h2><ul><li>std::move除了转换它的实参到右值以外什么也不做，有一些提议说它的名字叫rvalue_cast之类可能会更好。虽然可能确实是这样，但是它的名字已经是std::move，所以记住std::move做什么和不做什么很重要。它只进行转换，不移动任何东西。</li><li>右值可以用来初始化右值引用，这种情况下该右值所标识的对象的生存期被延长到该引用的作用域结尾。</li><li>static_cast<T>(v)<ul><li>如果T的类型为左值引用或者对函数指针的右值引用，结果为左值，同时T若为右值引用，返回结果为相应类型的<strong>亡值</strong>，其生命周期等于引用的生命周期</li><li>同时，static_cast 不太适用于向下转型，基类的左值(引用)转型为派生类左值引用时必须保证基类为派生类中的基类子对象(顾名思义为子类中is_a基类的部分)，结果可转为类型为D的封闭对象（enclosing object），否则UB</li><li>所以，static_cast在运行时不进行任何检查来确保被转换的对象实际上是目标类型的完整对象。因此，程序员需要确保转换是安全的。另一方面，它不会产生dynamic_cast的<strong>类型安全检查</strong>的开销。</li></ul></li></ul><h2 id="2-10-模板杂类"><a href="#2-10-模板杂类" class="headerlink" title="2.10. 模板杂类"></a>2.10. 模板杂类</h2><ul><li><p>c++模板是图灵完全的，可以在编译期对模板类进行求值,要进行编译期编程，最主要的一点，是需要把计算转变成类型推导。<br><a href="https://blog.csdn.net/fegus/article/details/130338576?ops_request_misc=&request_id=38815c79755449fe82293d93350e9293&biz_id=&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~koosearch~default-9-130338576-null-null.268%5Ev1%5Econtrol&utm_term=%E7%8E%B0%E4%BB%A3&spm=1018.2226.3001.4450">现代c++编程实战中关于模板编译期计算的讲解</a></p></li><li><p>T&amp;&amp; 当T作为成员函数模板形参时，表现出通用引用，或转发引用，根据传递的左值或者右值来决定是左值还是右值引用，而如同complex&amp;&amp;此类直接指定类名或者在模板类中指定T，亦或者将T&amp;&amp;前加上cv限定，一般都属于右值引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <br><span class="hljs-built_in">complex</span>(T&amp;&amp;)&#123;&#125; <span class="hljs-comment">// forward reference</span><br></code></pre></td></tr></table></figure><ul><li>一般来说都用std::forward<T>(param)来转发通用引用（有条件的转为右值引用），用std::move将右值引用转为右值，且不会影响cv限定</li></ul></li><li><p>如果你在按值返回的函数中，返回值绑定到右值引用或者通用引用上，需要对返回的引用使用std::move或者std::forward。要了解原因，考虑两个矩阵相加的operator+函数，左侧的矩阵为右值（可以被用来保存求值之后的和）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">Matrix                              <span class="hljs-comment">//按值返回</span><br><span class="hljs-keyword">operator</span>+(Matrix&amp;&amp; lhs, <span class="hljs-type">const</span> Matrix&amp; rhs)<br>&#123;<br>    lhs += rhs;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(lhs);        <span class="hljs-comment">//移动lhs到返回值中</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>通过在return语句中将lhs转换为右值（通过std::move），lhs可以移动到返回值的内存位置。如果省略了std::move调用，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">Matrix                              <span class="hljs-comment">//同之前一样</span><br><span class="hljs-keyword">operator</span>+(Matrix&amp;&amp; lhs, <span class="hljs-type">const</span> Matrix&amp; rhs)<br>&#123;<br>    lhs += rhs;<br>    <span class="hljs-keyword">return</span> lhs;                     <span class="hljs-comment">//拷贝lhs到返回值中</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>lhs是个左值的事实，会强制编译器拷贝它到返回值的内存空间。假定Matrix支持移动操作，并且比拷贝操作效率更高，在return语句中使用std::move的代码效率更高。</p></li><li><p>模板在使用之前必须先声明。模板的使用由友元声明构成，不是由模板的声明构成。实际的模板声明必须在友元声明之前。例如，编译系统尝试链接以下示例中生成的目标文件时，对未实例化的 operator&lt;&lt; 函数，会生成未定义错误。</p><ul><li>友元类，友元函数的相关知识<ul><li>在 C++11 中，一个类有两种形式的友元声明：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">F</span>;<br><span class="hljs-keyword">friend</span> F;<br></code></pre></td></tr></table></figure>如果最内层的命名空间中找不到任何具有该名称的现有类，则第一种形式引入新的类 F。 C++11：第二种形式不引入新的类；当类已声明时，可以使用该形式，而当将模板类型参数或 typedef 声明为 friend 时，必须使用该形式。 </li><li>如果声明以前未声明的 friend 函数，则该函数将被导出到封闭非类范围。friend 声明中声明的函数被视为已使用 extern 关键字声明。若使用</li></ul></li></ul></li><li><p>类模板的静态成员变量是所有同类型的类模板实例共享的一块数据。当多个目标文件中声明了同一类模板的同类型实例后，必然会产生跨目标文件链接。</p></li><li><p>在函数模板中的所有if语句的分支都会被实例化(instantiated)。实例化后的代码是否有用是在run-time决定，而函数调用的实例化是在complie-time。</p></li><li><p>缺省情况下，实例会进入特殊地址区域，链接程序会识别并丢弃重复项。</p><blockquote><p>注意，在本地mingw gcc环境下对多个源文件都引入头文件中关于模板特定实参的实例化并统一编译，结果成功，表明链接器会丢弃重复的实例化</p></blockquote></li></ul><h2 id="2-11-lambda"><a href="#2-11-lambda" class="headerlink" title="2.11. lambda"></a>2.11. lambda</h2><ul><li>lambda主体不能捕捉静态存储期限变量</li><li>lambda主体在读取被常量表达式初始化并被const修饰的整形或枚举常量或者constexpr修饰的常量的值时，可以不进行捕获</li><li>如果存在捕获默认项，则当前对象（*this）可以被隐式捕获。如果隐式捕获，则始终通过引用进行捕获，即使捕获默认项是&#x3D;。</li><li>const lambda  <ul><li>语法类似于：<code> const auto a = [&amp;i]()constexpr&#123;  return i; &#125;;</code></li><li>创建const闭包类型对象，只能调用const成员函数，也就是重载的operator()函数必须为const成员函数，这样在说明符序列中也不能加入mutable关键字<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> b = <span class="hljs-number">50</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> a = [&amp;i](<span class="hljs-type">int</span> b)<span class="hljs-keyword">constexpr</span>&#123; i = b;<span class="hljs-keyword">return</span> i; &#125;;<br>    <span class="hljs-built_in">a</span>(b);<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">foo</span>(<span class="hljs-number">42</span>) &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>这里i可以被改变的原因是i并不是一个常量引用(const int&amp;)，在const成员函数中引用不可以被更改指的是在这里i的类型为是<em>引用常量</em>,众所周知c++中并不存在引用常量，因为引用被初始化后就是一个常量，不可以再次被绑定到其他左值或右值上，若想要达到i引用的数据值不被改变，可以在foo传参时将i的类型改为const int</li></ul></li><li><strong>odr-use</strong><ul><li>lambda函数主体在ODR-use自动存储期变量或者this指针所指代的实体(entity)时，必须要隐式或显式的捕获它</li><li>如果lambda函数的主体odr-use被复制捕获的实体，则访问闭包类型的成员。如果它没有odr-use该实体，则访问原始对象(不发生捕获)。</li><li>在默认捕获为复制捕获的lambda主体中，任何可捕获实体的类型都像被捕获了一样（因此如果lambda不可变，则通常会添加const限定符），即使该实体在未求值的操作数中且未被捕获（例如在decltype中）。</li><li>任何被lambda函数隐式或显式捕获的变量都是ODR-use的</li></ul></li></ul><h2 id="2-12-成员函数指针"><a href="#2-12-成员函数指针" class="headerlink" title="2.12. 成员函数指针"></a>2.12. 成员函数指针</h2><ul><li>指向作为类 C 的成员的非静态成员函数 f 的指针，能准确地以表达式 &amp;C::f 初始化。在 C 的成员函数内，如 &amp;(C::f) 或 &amp;f，这样的表达式不构成成员函数指针。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123; std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; &#125;<br>    <br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">void</span> (C::* p)(<span class="hljs-type">int</span>) = &amp;C::f; <span class="hljs-comment">// 指向类 C 的成员函数 f 的指针</span><br>    C c;<br>    (c.*p)(<span class="hljs-number">1</span>);                  <span class="hljs-comment">// 打印 1</span><br>    C* cp = &amp;c;<br>    (cp-&gt;*p)(<span class="hljs-number">2</span>);                <span class="hljs-comment">// 打印 2</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-13-数据成员指针"><a href="#2-13-数据成员指针" class="headerlink" title="2.13. 数据成员指针"></a>2.13. 数据成员指针</h2><ul><li><p>指向作为类 C 的成员的非静态数据成员 m 的指针，能准确地以表达式 &amp;C::m 初始化。在 C 的成员函数中，如 &amp;(C::m) 或 &amp;m 这样的表达式不构成指向成员指针</p></li><li><p>类定义是一种类型声明，存在于代码块中，并没有分配内存空间；对类的数据成员取地址，得到的是类的数据成员在类内的相对偏移量；</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> &#123; <span class="hljs-type">int</span> m; &#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> C::* p = &amp;C::m;          <span class="hljs-comment">// 指向类 C 的数据成员 m</span><br>    C c = &#123;<span class="hljs-number">7</span>&#125;;<br>    std::cout &lt;&lt; c.*p &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;   <span class="hljs-comment">// 打印 7</span><br>    C* cp = &amp;c;<br>    cp-&gt;m = <span class="hljs-number">10</span>;<br>    std::cout &lt;&lt; cp-&gt;*p &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-comment">// 打印 10</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-14-虚函数"><a href="#2-14-虚函数" class="headerlink" title="2.14. 虚函数"></a>2.14. 虚函数</h2><h3 id="2-14-1-从汇编层面理解虚函数的实现"><a href="#2-14-1-从汇编层面理解虚函数的实现" class="headerlink" title="2.14.1. 从汇编层面理解虚函数的实现"></a>2.14.1. 从汇编层面理解虚函数的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">parent_virtual</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">parent_virtual2</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Child</span> : Parent&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">parent_virtual</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">parent_virtual2</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Parent* p1 = <span class="hljs-keyword">new</span> Child;<br>    p1-&gt;<span class="hljs-built_in">parent_virtual2</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>经<a href="https://godbolt.org/">x86-64_gcc7.5</a>编译器编译后， 汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs assembly">square(int):<br>        push    rbp<br>        mov     rbp, rsp<br>        mov     DWORD PTR [rbp-4], edi<br>        mov     eax, DWORD PTR [rbp-4]<br>        imul    eax, DWORD PTR [rbp-4]<br>        pop     rbp<br>        ret<br>Parent::parent_virtual():<br>        push    rbp<br>        mov     rbp, rsp<br>        mov     QWORD PTR [rbp-8], rdi<br>        nop<br>        pop     rbp<br>        ret<br>Parent::parent_virtual2():<br>        push    rbp<br>        mov     rbp, rsp<br>        mov     QWORD PTR [rbp-8], rdi<br>        nop<br>        pop     rbp<br>        ret<br>Child::parent_virtual():<br>        push    rbp<br>        mov     rbp, rsp<br>        mov     QWORD PTR [rbp-8], rdi<br>        nop<br>        pop     rbp<br>        ret<br>Child::parent_virtual2():<br>        push    rbp<br>        mov     rbp, rsp<br>        mov     QWORD PTR [rbp-8], rdi<br>        nop<br>        pop     rbp<br>        ret<br>Parent::Parent() [base object constructor]:<br>        push    rbp<br>        mov     rbp, rsp<br>        mov     QWORD PTR [rbp-8], rdi<br>        mov     edx, OFFSET FLAT:vtable for Parent+16<br>        mov     rax, QWORD PTR [rbp-8]<br>        mov     QWORD PTR [rax], rdx<br>        nop<br>        pop     rbp<br>        ret<br>Child::Child() [base object constructor]:<br>        push    rbp<br>        mov     rbp, rsp<br>        sub     rsp, 16<br>        mov     QWORD PTR [rbp-8], rdi<br>        mov     rax, QWORD PTR [rbp-8]<br>        mov     rdi, rax<br>        call    Parent::Parent() [base object constructor]<br>        mov     edx, OFFSET FLAT:vtable for Child+16<br>        mov     rax, QWORD PTR [rbp-8]<br>        mov     QWORD PTR [rax], rdx<br>        nop<br>        leave<br>        ret<br>main:<br>        push    rbp<br>        mov     rbp, rsp<br>        push    rbx<br>        sub     rsp, 24<br>        mov     edi, 8<br>        call    operator new(unsigned long)<br>        mov     rbx, rax<br>        mov     rdi, rbx<br>        call    Child::Child() [complete object constructor]<br>        mov     QWORD PTR [rbp-24], rbx<br>        mov     rax, QWORD PTR [rbp-24]<br>        mov     rax, QWORD PTR [rax]<br>        add     rax, 8<br>        mov     rax, QWORD PTR [rax]<br>        mov     rdx, QWORD PTR [rbp-24]<br>        mov     rdi, rdx<br>        call    rax<br>        mov     eax, 0<br>        add     rsp, 24<br>        pop     rbx<br>        pop     rbp<br>        ret<br>vtable for Child:<br>        .quad   0<br>        .quad   typeinfo for Child<br>        .quad   Child::parent_virtual()<br>        .quad   Child::parent_virtual2()<br>vtable for Parent:<br>        .quad   0<br>        .quad   typeinfo for Parent<br>        .quad   Parent::parent_virtual()<br>        .quad   Parent::parent_virtual2()<br>typeinfo for Child:<br>        .quad   vtable for __cxxabiv1::__si_class_type_info+16<br>        .quad   typeinfo name for Child<br>        .quad   typeinfo for Parent<br>typeinfo name for Child:<br>        .string &quot;5Child&quot;<br>typeinfo for Parent:<br>        .quad   vtable for __cxxabiv1::__class_type_info+16<br>        .quad   typeinfo name for Parent<br>typeinfo name for Parent:<br>        .string &quot;6Parent&quot;<br><br></code></pre></td></tr></table></figure><p>以下是对主函数汇编段代码的解释：</p><ul><li><p>push rbp：将 rbp 寄存器的值压入栈中，保存当前的基址指针。</p></li><li><p>mov rbp, rsp：将 rsp 寄存器的值赋给 rbp 寄存器，设置新的基址指针</p></li><li><p>push rbx：将 rbx 寄存器的值压入栈中，保存当前的基址寄存器</p></li><li><p>sub rsp, 24：将 rsp 寄存器的值减去 24，为局部变量分配空间</p></li><li><p>mov edi, 8：将 8 赋给 edi 寄存器，作为 operator new 的参数，表示要分配 8 个字节的内存</p></li><li><p>call operator new(unsigned long)：调用 operator new 函数，为 Child 对象分配内存空间，并将返回的地址放在 rax 寄存器中</p></li><li><p>mov rbx, rax：将 rax 寄存器的值赋给 rbx 寄存器，保存 Child 对象的地址</p></li><li><p>mov rdi, rbx：将 rbx 寄存器的值赋给 rdi 寄存器，作为 Child::Child() 的参数，表示要构造 Child 对象</p></li><li><p>call Child::Child() [complete object constructor]：调用 Child::Child() 函数，完成 Child 对象的构造过程</p></li><li><p>mov QWORD PTR [rbp-24], rbx：将 rbx 寄存器的值（Child 对象的地址）赋给 [rbp-24] 指向的内存单元（局部变量）</p></li><li><p>mov rax, QWORD PTR [rbp-24]：将 [rbp-24] 指向的内存单元（局部变量）的值（Child 对象的地址）赋给 rax 寄存器</p></li><li><p>mov rax, QWORD PTR [rax]：将 [rax] 指向的内存单元（Child 对象中第一个成员变量）的值（虚函数表指针）赋给 rax 寄存器</p></li><li><p>mov rax, QWORD PTR [rax]：将 [rax] 指向的内存单元（虚函数表中第一个函数指针）的值（虚函数地址）赋给 rax 寄存器</p></li><li><p>mov rdx, QWORD PTR [rbp-24]：将 [rbp-24] 指向的内存单元（局部变量）的值（Child 对象的地址）赋给 rdx 寄存器</p></li><li><p>mov rdi, rdx：将 rdx 寄存器的值（Child 对象的地址）赋给 rdi 寄存器，作为虚函数的参数，表示要调用 Child 对象的虚函数</p></li><li><p>call rax：调用 rax 寄存器中保存的函数地址（虚函数地址），执行 Child 对象的虚函数，并将返回值放在 rax 寄存器中</p></li><li><p>mov eax, 0：将 0 赋给 eax 寄存器，作为 main 函数的返回值</p></li><li><p>add rsp, 24：将 rsp 寄存器的值加上 24，释放局部变量占用的空间</p></li><li><p>pop rbx：从栈中弹出一个值，赋给 rbx 寄存器，恢复之前保存的基址寄存器</p></li><li><p>pop rbp：从栈中弹出一个值，赋给 rbp 寄存器，恢复之前保存的基址指针</p></li><li><p>ret：从栈中弹出一个值，作为返回地址，并跳转到该地址继续执行。</p><blockquote><p>总结来说，比较老旧的编译器无法直接对<strong>指针或者引用下</strong>虚函数的调用进行静态绑定（值语义下可以，值语义指的是直接使用对象的.方法调用虚函数），即直接使用call functionname的做法，必须通过当前指针所指向的对象，查找其内存模型的第一个成员地址，也就是vptr的位置，之后通过vptr找到其指向的vtbl(虚表), vtbl是可以看作一个存放虚函数地址的数组，单个继承下无论是父类还是子类其每个虚函数的的偏移量在虚表中是相同的（索引是相同的），运行期可以直接通过该虚函数的地址来调用虚函数。所以编译器在编译期就已经构建并维护了虚指针和虚表，具体创建时间是在该类的对象的构造函数被调用之后，在较新的编译器中编译相同代码，编译器可能直接对虚函数进行静态绑定, 在c++11之后，子类使用<strong>final</strong>来覆写虚函数后，用<strong>子类指针或引用</strong>来调用虚函数，也可以做到静态绑定</p></blockquote></li></ul><h3 id="2-14-2-虚析构函数"><a href="#2-14-2-虚析构函数" class="headerlink" title="2.14.2. 虚析构函数"></a>2.14.2. 虚析构函数</h3><ul><li><p>通过指向基类的指针删除对象会引发未定义行为，除非基类的析构函数是虚函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123;&#125;<br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;&#125;;<br> <br>Base* b = <span class="hljs-keyword">new</span> Derived;<br><span class="hljs-keyword">delete</span> b; <span class="hljs-comment">// 安全</span><br><br></code></pre></td></tr></table></figure></li><li><p>析构函数可以声明为纯虚的，例如对于需要声明为抽象类，但没有其他可声明为纯虚的适合函数的基类。纯虚析构函数必须有定义，因为在销毁派生类时，所有基类析构函数都会被调用：</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractBase</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">AbstractBase</span>() = <span class="hljs-number">0</span>;<br>&#125;;<br>AbstractBase::~<span class="hljs-built_in">AbstractBase</span>() &#123;&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> AbstractBase &#123;&#125;;<br> <br><span class="hljs-comment">// AbstractBase obj; // 编译错误</span><br>Derived obj;         <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><p>几个讲解虚函数讲的不错的博客：<br><a href="https://jacktang816.github.io/post/virtualfunction/">虚函数的内存分布</a><br><a href="http://www.fmddlmyy.cn/text15.html">C++基本概念在编译器中的实现</a><br><a href="https://mp.weixin.qq.com/s/FJfSkrRKvuOmAfqqgf_e8Q">多态实现-虚函数、函数指针以及变体</a></p><h2 id="2-15-虚基类"><a href="#2-15-虚基类" class="headerlink" title="2.15. 虚基类"></a>2.15. 虚基类</h2><p>这里贴出一篇<a href="https://blog.csdn.net/xiejingfa/article/details/48028491">博客</a>，讲解了虚基类在内存中的分布</p><h1 id="3-2023-9-1"><a href="#3-2023-9-1" class="headerlink" title="3. 2023&#x2F;9&#x2F;1"></a>3. 2023&#x2F;9&#x2F;1</h1><h2 id="3-1-std-bind"><a href="#3-1-std-bind" class="headerlink" title="3.1. std::bind"></a>3.1. std::bind</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;<span class="hljs-type">double</span>&gt; data;               <span class="hljs-comment">//同上</span><br><br>…                                       <span class="hljs-comment">//同上</span><br><br><span class="hljs-keyword">auto</span> func =<br>    std::<span class="hljs-built_in">bind</span>(                              <span class="hljs-comment">//C++11模拟初始化捕获</span><br>        [](<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">double</span>&gt;&amp; data) <span class="hljs-comment">//译者注：本行高亮</span><br>        &#123; <span class="hljs-comment">/*使用data*/</span> &#125;,<br>        std::<span class="hljs-built_in">move</span>(data)                     <span class="hljs-comment">//译者注：本行高亮</span><br>    );<br><br></code></pre></td></tr></table></figure><ul><li>std::bind为每个实参创建了bind对象里的<strong>副本</strong>，每次调用bind对象时，调用的是传递给lambda表达式的本地副本。在如上的例子中，std::move(data)使用移动构造创建了本地副本（左值），之后每次调用函数副本时，调用的都是该副本</li></ul><h2 id="3-2-关于初始化的一些想法，表述上可能有纰漏，但根据代码执行来看应该是正确的"><a href="#3-2-关于初始化的一些想法，表述上可能有纰漏，但根据代码执行来看应该是正确的" class="headerlink" title="3.2. 关于初始化的一些想法，表述上可能有纰漏，但根据代码执行来看应该是正确的"></a>3.2. 关于初始化的一些想法，表述上可能有纰漏，但根据代码执行来看应该是正确的</h2><h3 id="3-2-1-值初始化"><a href="#3-2-1-值初始化" class="headerlink" title="3.2.1. 值初始化"></a>3.2.1. 值初始化</h3><ul><li><p>形式: T() &#x2F; T{}</p></li><li><p>若T为类对象且有用户提供（<em>除了在类定义内直接显式指定default的默认构造函数都可以称为用户提供的默认构造函数</em>）的默认构造函数，则对对象进行<strong>默认初始化</strong>；</p></li><li><p>若T为类对象且T只有隐式生成的默认构造函数，或者只有在类定义内指定default的默认构造函数，换而言之，如果显式定义&#x2F;预置&#x2F;删除了转换构造，拷贝或者移动构造（经过实验发现赋值操作不会影响默认构造函数的隐式生成），那么默认构造函数就不会隐式生成，如果默认构造函数隐式生成或被显式预置（后者前提是没有用户提供或者显示删除的默认构造函数），则会首先对类对象进行<strong>零初始化</strong>(即所有bit位置零)，之后会通过语义限制检查默认构造函数是否为<strong>重要(non-trivial)<strong>的默认构造函数，来对其中的对象进行</strong>默认初始化</strong></p><p><em>trivial default constructor</em> :  </p><ul><li>不是用户提供（即隐式生成或者首次声明时就显式预置）  </li><li>对应的类没有虚函数或者虚基类</li><li>直接基类拥有trivial default ctor</li><li>非静态成员同上</li></ul></li><li><p>所有标准容器（std::vector、std::list 等）在以单个 size_type 实参进行构造或由对 resize() 的调用而增长时值初始化它们的各个元素，除非它们的分配器定制 construct 的行为。</p></li></ul><h3 id="3-2-2-默认初始化"><a href="#3-2-2-默认初始化" class="headerlink" title="3.2.2. 默认初始化"></a>3.2.2. 默认初始化</h3><ul><li>形式： T obj&#x2F; new T;</li><li>调用无参默认构造函数，并对没有<strong>在成员初始化列表进行指明</strong>或者<strong>没有默认成员初始化器</strong>的非静态成员和基类成员进行默认初始化</li><li>注意： <strong>对自动&#x2F;动态存储期非类类型成员进行默认初始化时会获得不确定的值</strong>，这也是我想讨论的重点，比如对int成员变量进行默认初始化之后，使用其赋值会导致UB</li><li>使用默认初始化初始化const修饰的对象时，若为类对象必须有用户定义或提供的默认构造函数，或者每个非静态成员都有成员默认初始化器。最重要的是对应的基类子对象也必须满足上述条件</li><li>tips: <em>member initializer list</em> 中没有出现但在函数主体中出现的成员变量在进入函数主体前被默认初始化，这要求其必须具备<strong>默认构造函数</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">T1</span> &#123; <span class="hljs-type">int</span> mem; &#125;;<br> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">T2</span><br>&#123;<br>    <span class="hljs-type">int</span> mem;<br>    <span class="hljs-built_in">T2</span>() &#123; &#125; <span class="hljs-comment">// &quot;mem&quot; is not in the initializer list</span><br>&#125;;<br> <br><span class="hljs-type">int</span> n; <span class="hljs-comment">// static non-class, a two-phase initialization is done:</span><br>       <span class="hljs-comment">// 1) zero-initialization initializes n to zero</span><br>       <span class="hljs-comment">// 2) default-initialization does nothing, leaving n being zero</span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    [[maybe_unused]]<br>    <span class="hljs-type">int</span> n;            <span class="hljs-comment">// non-class, the value is indeterminate</span><br>    std::string s;    <span class="hljs-comment">// class, calls default ctor, the value is &quot;&quot; (empty string)</span><br>    std::string a[<span class="hljs-number">2</span>]; <span class="hljs-comment">// array, default-initializes the elements, the value is &#123;&quot;&quot;, &quot;&quot;&#125;</span><br><span class="hljs-comment">//  int&amp; r;           // error: a reference</span><br><span class="hljs-comment">//  const int n;      // error: a const non-class</span><br><span class="hljs-comment">//  const T1 t1;      // error: const class with implicit default ctor</span><br>    [[maybe_unused]]<br>    T1 t1;            <span class="hljs-comment">// class, calls implicit default ctor</span><br>    <span class="hljs-type">const</span> T2 t2;      <span class="hljs-comment">// const class, calls the user-provided default ctor</span><br>                      <span class="hljs-comment">// t2.mem is default-initialized (to indeterminate value)</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>若用clang编译器进行编译，输出t1.mem会发现是随机值，用gcc编译器进行编译会发现编译器给出‘uninitiated value’警告但仍然进行了零初始化，若改写为T1 t1{}，则都能正常编译并对进行mem零初始化，这就是我认为值初始化和默认初始化的最大区别所在；</p></blockquote></li></ul><h3 id="3-2-3-静态成员的初始化"><a href="#3-2-3-静态成员的初始化" class="headerlink" title="3.2.3. 静态成员的初始化"></a>3.2.3. 静态成员的初始化</h3><ul><li>具有static(<em>全局变量或static声明</em>)或 thread 存储期限的<strong>非局部变量</strong>在程序开始前被初始化，存放在全局区，先进行<strong>静态初始化</strong>，再进行<strong>动态初始化</strong>, 全局区分为已被初始化的段(.data段)，和未被初始化的段(.bss段)<ul><li>静态初始化一般来说就是指零初始化和常量初始化，动态初始化在 <a href="%5Bhttps://%5D(https://en.cppreference.com/w/cpp/language/initialization#Non-local_variables)">cppreference</a>中并没给出明确定义，网络上对于这方面的相关资料也甚少，但值得注意的是，<strong>若没有被常量初始化的静态非局部变量在其他初始化进行前都会进行零初始化</strong>，之后会根据变量的定义来判断是否改变变量的值，但变量此时必须出现定义，若无定义则会报<strong>undefined reference</strong> 错误！！</li><li>动态初始化一般来说（有别的像无序或部分有序，太复杂）是按照静态非局部变量的定义顺序来进行初始化的</li></ul></li><li>static <strong>局部变量</strong> 拥有静态存储期限，但初始化是在第一次进入scope 作用域并执行到变量声明时初始化，除非他是被 <strong>零初始化</strong> (加载程序时被设为0，一般存储在BSS段)或者 <strong>常量初始化</strong>(编译时间)，这让他们可以像全局变量一样在程序开始前被初始化</li><li>具有自动和动态存储期的非类变量的默认初始化，生成具有不确定值的对象(静态和线程局部对象的初始化为零)。</li><li>引用和常量标量对象不能被默认初始化。<ul><li>标量类型(scalar types)包括integral，reference，floating-point, pointer…………………………..</li></ul></li><li>静态数据成员(static data  members) 在声明<strong>内联或constexpr</strong>时指定initialzer , 在类外不需要重定义，甚至在odr-use时也不需要定义，然而对于普通const成员来说，只有int类型的数据才可以拥有initializer，并且在odr-use时也需要在类外重新声明，但这时不能给出初始化器</li><li>总结就是类静态成员在类中声明时是不会默认初始化的，可以在类外定义进行动态初始化，在类外的静态数据可以直接默认初始化.</li></ul><h4 id="3-2-3-1-2023-11-1-更新动态初始化"><a href="#3-2-3-1-2023-11-1-更新动态初始化" class="headerlink" title="3.2.3.1. 2023&#x2F;11&#x2F;1 更新动态初始化"></a>3.2.3.1. 2023&#x2F;11&#x2F;1 更新动态初始化</h4><p>在动手查看过各静态变量汇编层面的动态初始化后，对动态初始化有了更多的认识<br>代码文件及汇编代码在<a href="https://godbolt.org/z/METvfhPj3">complier explore</a>，编译器为x86-64 clang9.0;</p><ol><li>对于未初始化的普通数据类型静态或全局变量（即没有初始化器）来说， 其被储存在.bss段中且这些0变量本身并没有保存在可执行文件或者动态链接库文件中，但是其总内存段大小和起止位置在加载件时被统计出来。<ul><li>C++ name-mangling机制把<strong>这类数据以及局部静态未初始化或者零初始化或者动态初始化变量</strong>命名为_ZZ3fooiE开头的变量，用于表示一个静态变量的实际存储位置，根据下面对于动态初始化局部静态变量的汇编代码可以看出，编译器它调用了一些C++运行时库的函数，如__cxa_guard_acquire和__cxa_guard_release，来保证初始化的线程安全和一次性(<strong>详情见内存屏障</strong>) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">cmp     byte ptr [guard variable for foo(int)::staticLocalInitVar], 0<br>jne     .LBB1_3<br>movabs  rdi, offset guard variable for foo(int)::staticLocalInitVar<br>call    __cxa_guard_acquire<br>cmp     eax, 0<br>je      .LBB1_3<br>call    fd()<br>mov     dword ptr [_ZZ3fooiE18staticLocalInitVar], eax<br>movabs  rdi, offset guard variable for foo(int)::staticLocalInitVar<br>call    __cxa_guard_release<br></code></pre></td></tr></table></figure></li></ul></li><li>对于有初始化器但不是常量初始化的普通数据类型静态或全局变量来说，其被存储在.data段中，但编译阶段被初始化为0，其被真正初始化的阶段在运行期，program startup的阶段，在主函数执行之前被无序，偏序，或正序初始化。对于clang为每个静态数据成员在编译阶段分配了其初始化的，名称为__cxx_global_var_init.<strong>num</strong>的函数代码，到startup时会被__start函数调用<ul><li>无序初始化针对模板类<strong>没有被特化</strong>的静态数据成员（<em>当然前提是该数据成员不是在类中被赋值的常量整形成员，也不是指定constexpr的内联静态成员</em>），其生成函数的num不一定在它之后声明的变量之前</li><li>偏序初始化针对内联静态变量</li><li>其余静态变量或普通类的静态数据成员在同一翻译单元中按照代码顺序动态初始化</li></ul></li><li>对于class类型的全局成员来说，.data段将其非静态数据成员全部零初始化，并且构造函数也在startup阶段被调用，析构函数在主函数退出后也被调用</li><li>还有一种动态初始化可以提早发生在编译阶段，其必须满足以下条件<ul><li>初始化的动态版本不改变命名空间作用域中任何先于其初始化的对象的值</li><li>初始化的静态版本在被初始化变量中产生的值，与当所有不要求静态初始化的变量都被动态初始化时，由动态初始化所生成的值相同。<br>但这只是可能提前初始化，并不保证一定会</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title">fd</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>; &#125;<br> <br><span class="hljs-keyword">extern</span> <span class="hljs-type">double</span> d1;<br> <br><span class="hljs-type">double</span> d2 = d1;   <span class="hljs-comment">// unspecified:</span><br>                  <span class="hljs-comment">// dynamically initialized to 0.0 if d1 is dynamically initialized, or</span><br>                  <span class="hljs-comment">// dynamically initialized to 1.0 if d1 is statically initialized, or</span><br>                  <span class="hljs-comment">// statically initialized to 0.0 (because that would be its value</span><br>                  <span class="hljs-comment">// if both variables were dynamically initialized)</span><br> <br><span class="hljs-type">double</span> d1 = <span class="hljs-built_in">fd</span>(); <span class="hljs-comment">// may be initialized statically or dynamically to 1.0</span><br></code></pre></td></tr></table></figure><blockquote><p>简而言之，d1在程序开始前被赋0，这是静态初始化，之后被赋1，这是动态初始化，但由于某些规则该变量的动态初始化可以被提至编译时间，也就是静态初始化为1，所以d2的值也是不确定的，虽然在本地表现出被动态初始化为1的结果</p></blockquote><p>-[] 依然困惑于动态初始化的局部静态变量，在汇编码中没有找到其在.data段被分配内存，莫非仍然在.bss段被分配内存？</p><h2 id="3-3-internal-linkage-external-linkage"><a href="#3-3-internal-linkage-external-linkage" class="headerlink" title="3.3. internal linkage &amp;&amp; external linkage"></a>3.3. internal linkage &amp;&amp; external linkage</h2><ul><li>#pragma once 只能作用于某个具体的文件，而无法向 #ifndef 那样仅作用于指定的一段代码</li><li>具有内部链接性质的变量可以在头文件中定义，这样会在每个翻译单元内定义不同实体，但由于该变量只在单文件中可见于是不会引发多重定义的问题， 但是会引发代码冗余</li><li>具有外部链接性质的变量或者函数若声明inline，则会在编译时将变量名替换为变量值 &#x2F; 函数名替换为函数体， 此时可以在头文件中定义</li><li>类类型虽然在cppreference中标注类的名称具有外部链接，但在源文件中使用类时（比如构造函数，成员函数等等时），若只在开头标注class complex；是会导致编译错误的，必须要引入class头文件，但是类的静态数据成员和成员函数都具有外部链接，可以在类外定义（另一个源文件，若在头文件定义，需在类外声明inline，若在类内则不需要，因为在类内定义是隐式内联的），<strong>根据ODR原则可知ODR允许类类型在多个翻译单元中定义，特别地，对于需要该类类型完整定义的翻译单元中，必须有且仅有该类类型的一个定义，并且在满足特定条件时，如同整个程序中只有一个定义。</strong></li><li>匿名命名空间也不要在头文件定义，因为每个引入该命名空间的源文件都会为自己创建一份独特命名的命名空间，可能会导致很多意外情况发生</li></ul><p><a href="https://www.cnblogs.com/shaochuanhe/articles/14238153.html">讲述c++编译时会出现多重定义，链接错误等error原因的博客</a></p><h2 id="3-4-C、C99、ANSI-C-和-GNU-C-之间的区别"><a href="#3-4-C、C99、ANSI-C-和-GNU-C-之间的区别" class="headerlink" title="3.4. C、C99、ANSI C 和 GNU C 之间的区别"></a>3.4. C、C99、ANSI C 和 GNU C 之间的区别</h2><p>标准化之前的一切一般被称为“K&amp;R C”，以著名的书（第一版和第二版）命名，C语言的发明者丹尼斯·里奇（Dennis Ritchie）是作者之一。这就是 1972 年至 1989 年的“C 语言”。</p><p>第一个 C 标准于 1989 年由美国国家标准协会 ANSI 在全国发布。此版本称为 C89 或 ANSI-C。从 1989 年到 1990 年，这就是“C 语言”。</p><p>次年，美国标准被国际接受并由 ISO 发布（ISO 9899:1990）。此版本称为 C90。从技术上来说，它与C89&#x2F;ANSI-C是相同的标准。从形式上来说，它取代了 C89&#x2F;ANSI-C，使它们变得过时。从 1990 年到 1999 年，C90 是“C 语言”。</p><p>请注意，自 1989 年以来，ANSI 与 C 语言没有任何关系，只是作为 ISO 标准的众多实例之一。现在在美国通过INCITS完成，C 标准在美国的正式名称为 INCITS&#x2F;ISO&#x2F;IEC 9899。就像在欧洲称为 EN&#x2F;ISO&#x2F;IEC 一样。</p><p>仍在谈论“ANSI C”的程序员通常不知道它的含义。ISO 通过 ISO 9899 标准“拥有”C 语言。</p><p>1995 年发布了一个小更新，有时称为“C95”。这不是重大修订，而是正式命名为 ISO&#x2F;IEC 9899:1990&#x2F;Amd.1:1995 的技术修订。主要的变化是引入了广泛的字符支持。</p><p>1999年，C标准进行了重大修订（ISO 9899:1999）。该版本的标准称为 C99。从 1999 年到 2011 年，这就是“C 语言”。</p><p>2011年，C标准再次发生变更（ISO 9899:2011）。这个版本称为C11。该语言中添加了各种新功能，例如_Generic、和线程支持。_Static_assert此次更新重点关注多核、多处理和表达测序。从 2011 年到 2017 年，这就是“C 语言”。</p><p>2017年，C11进行了改版，解决了各种缺陷报告。该标准非正式地称为 C17 或 C18。它于 2017 年完成（并使用__STDC_VERSION__&#x3D; 201710L），但由 ISO 发布为 9899:2018，因此 C17&#x2F;C18 之间存在歧义。它不包含任何新功能，仅包含更正。它是 C 语言的当前版本。</p><p>该委员会正在制定一项名为“C23”&#x2F;“C2X”的草案，计划于 2023 年发布（但官僚主义的车轮磨得很慢，请检查ISO 的状态）。最后的工作草案 N3096 可在此处找到。</p><p>其中包含许多小缺陷报告修复，例如 C17&#x2F;C18，但也包含许多重大更改和新功能。这是一个主要版本。</p><p>“C99 strict”可能是指强制编译器严格遵循标准的编译器设置。C 标准中有一个术语“conformedimplementation” 。本质上它的意思是：“这个编译器实际上正确地实现了C语言”。正确实现 C 语言的程序正式称为严格符合程序。此类程序也可能不包含任何形式的定义不明确的行为。</p><p>“GNU C”有两个含义。作为 GNU 编译器集合 (GCC) 一部分的 C 编译器本身。或者它可能意味着 GCC C 编译器使用的非标准默认设置。如果您使用它进行编译，gcc program.c那么您就不会根据 C 标准进行编译，而是根据非标准 GNU 设置进行编译，这可能被称为“GNU C”。例如，整个 Linux 内核是用非标准 GNU C 编写的，而不是用标准 C 编写的。</p><h1 id="4-未完成的学习任务"><a href="#4-未完成的学习任务" class="headerlink" title="4. 未完成的学习任务"></a>4. 未完成的学习任务</h1><ul><li><input disabled="" type="checkbox"> c++程序加载时的内存模型(编译期内存的分配以及运行期内存的分配)<br><a href="https://ctfbook.ph0en1x.com/reverse/zhan-3001-zhan-zheng-yu-han-shu-diao-yong">栈、栈帧与函数调用</a><br><a href="https://www.tenouk.com/ModuleW.html">COMPILER, ASSEMBLER, LINKER AND LOADER: A BRIEF STORY</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>cpp related</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c11/14 syntax</tag>
      
      <tag>cpp memory model</tag>
      
      <tag>static/dynamic polymorphic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用的最短路算法总结</title>
    <link href="/2023/08/24/cplus-learning/"/>
    <url>/2023/08/24/cplus-learning/</url>
    
    <content type="html"><![CDATA[<h1 id="2023-8-2"><a href="#2023-8-2" class="headerlink" title="2023&#x2F;8&#x2F;2"></a>2023&#x2F;8&#x2F;2</h1><ul><li>dijstra，每次并入一个节点并更新dist值，下面列举几种不同实现方式<ul><li>邻接矩阵 时间复杂度为O(v^2)</li><li>邻接链表，每个顶点连着跟他相连的顶点作为链表中的节点，存储着目的顶点和边的权重，时间复杂度为O(Elogv) 可以用list&lt;pair&lt;int(目的顶点),int(边的权重)&gt;&gt;<ul><li><strong>最小堆</strong><ul><li>基本知识：最小堆是一个完全二叉树，节点值由一个数组维护，每个左右子树的父节点的值都比子节点的值小</li><li>构建最小堆：完全二叉树的非叶子节点数量为[N&#x2F;2]，N为节点数量<blockquote><p>证明：<br>设出度数为0，1，2的节点数分别为x, y, z，由完全二叉树的性质可知，y为0(N为奇数)或1(N为偶数)，且有以下公式：<br> x + y + z &#x3D; N, 2x + y &#x3D; N - 1(边的数量，除了头节点每个节点都被一条边牵引)<br>则可得出 x + y &#x3D; N &#x2F; 2(向下取整)</p></blockquote>构建堆时叶子节点由于没用子节点，我们可以将其认为是已经构建好的子堆，那我们可以从最后一个非叶子节点开始以此执行<strong>下沉</strong>操作, 总时间复杂度为O(N)</li><li>下沉：递归比较父节点和左右子节点中较大节点的值，若小于，则交换, 时间复杂度为O(logN)</li><li>上浮：递归比较要操作的子节点和父节点中较大节点的值，若小于，则交换，时间复杂度为O(logN)</li><li>提取最小值&#x2F;删除操作：将堆中最小值节点，也就是根节点和数组中最后一个节点调换位置，并减少堆中size的值，之后进行堆化操作</li><li>插入元素：在数组末尾新增元素，并执行上浮操作</li><li>减少键值：<strong>减小</strong>堆中某个节点的值(直接在数组中针对索引进行操作)，由于是减小了键值所以之后执行上浮操作</li><li>STL中实现的<em>priority_queue</em>默认实现<strong>最大堆</strong>，和最小堆完全相反，其父节点的值要大于左右子树的值</li></ul></li></ul></li><li>stl set : 集合的定义，每个元素只有一份在集合中</li><li>std::tie是C++标准库中的一个函数模板，位于<tuple>头文件中。std::tie用于创建一个std::tuple元组，可以用来绑定多个变量，并从中提取元素值。</li><li>std::tie的用法是将多个变量作为参数传递给它，并返回一个元组，其中包含这些变量的引用。可以使用std::tie来简洁地同时解包多个变量。</li><li>myset.erase(myset.find(40)); 只删除第一个匹配到的元素，而 myset.erase(40); 会删除所有匹配到的元素。</li><li>set的默认排序方式为升序排序，priority_queue相反 </li><li>std::sort(myints, myints+8, myfunction&#x2F;myobject(strcut or class仿函数)) &#x2F; std::set&lt;int, less<int>&#x2F;greater<int>&#x2F;myfunctionobject&#x2F;bool(*)(int, int)&gt; myset(myfunction)</li><li>pair的默认排序方式按pair.first排序</li><li>常见的实现方法为BFS，每次从队列或集合中取出最小的dist所对应的节点，松弛该节点相连的所有边，若有更新，将更新后的pair加入至队列中</li><li>为了防止遍历到已经提取出最小值的节点，可以加入vis数组，但加不加无所谓，最终都会收敛至最小值</li></ul></li></ul><p><img src="/image/dijkstra.png"></p><h1 id="2023-8-3"><a href="#2023-8-3" class="headerlink" title="2023&#x2F;8&#x2F;3"></a>2023&#x2F;8&#x2F;3</h1><ul><li>原地哈希：将原数组的元素对应到其下标中，比如1对应的下标为1-1&#x3D;0，还可以使用替换的方式将0索引上的数字与1进行交换，该方式可以用来查看某个数字是否出现在了数组中。</li></ul>]]></content>
    
    
    <categories>
      
      <category>cpp related</category>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dijstra</tag>
      
      <tag>hash table</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识c++</title>
    <link href="/2023/07/24/introduction/"/>
    <url>/2023/07/24/introduction/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="#1-2023713">1. 2023&#x2F;7&#x2F;13</a><ul><li><a href="#11-contribut">1.1. Contribut</a></li></ul></li><li><a href="#2-2023714">2. 2023&#x2F;7&#x2F;14</a><ul><li><a href="#21-cpp-learning">2.1. cpp learning</a></li></ul></li><li><a href="#3-2023720">3. 2023&#x2F;7&#x2F;20</a></li><li><a href="#4-2023724">4. 2023&#x2F;7&#x2F;24</a></li><li><a href="#5-2023725">5. 2023&#x2F;7&#x2F;25</a></li><li><a href="#6-2023726">6. 2023&#x2F;7&#x2F;26</a></li></ul><h1 id="1-2023-7-13"><a href="#1-2023-7-13" class="headerlink" title="1. 2023&#x2F;7&#x2F;13"></a>1. 2023&#x2F;7&#x2F;13</h1><h2 id="1-1-Contribut"><a href="#1-1-Contribut" class="headerlink" title="1.1. Contribut"></a>1.1. Contribut</h2><ul><li>剑桥雅思真题</li><li>manium数学动画</li><li><input checked="" disabled="" type="checkbox"> <a href="https://github.com/">https://github.com/</a></li></ul><ol><li>public&#x2F;private&#x2F;protected cpp</li><li>friend cpp</li><li>non-virtual function cpp <blockquote></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">example</span> <span class="hljs-params">()</span> </span>&#123;<br>&#125;<span class="hljs-type">const</span> = <span class="hljs-number">0</span>; <br></code></pre></td></tr></table></figure></li></ol><h1 id="2-2023-7-14"><a href="#2-2023-7-14" class="headerlink" title="2. 2023&#x2F;7&#x2F;14"></a>2. 2023&#x2F;7&#x2F;14</h1><h2 id="2-1-cpp-learning"><a href="#2-1-cpp-learning" class="headerlink" title="2.1. cpp learning"></a>2.1. cpp learning</h2><ul><li><p>stringstream<br><strong>used to split word</strong><br><br><code>using namespace std;</code></p></li><li><p>to_string(int):change a int to a string  </p><blockquote><p>仅作测试样例<br> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%-3d&quot;</span>,a);<br>&#125;<br></code></pre></td></tr></table></figure></p></blockquote></li><li><p>字典树 <a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247488490&idx=1&sn=db2998cb0e5f08684ee1b6009b974089">查找匹配字符，其实就是树节点存储26个字母</a></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Trie</span> &#123;<br>        <span class="hljs-type">bool</span> isEnd;<br>        vector&lt;Trie*&gt; children;<br>        <span class="hljs-built_in">Trie</span>() : <span class="hljs-built_in">isEnd</span>(<span class="hljs-literal">false</span>), <span class="hljs-built_in">children</span>(<span class="hljs-number">26</span>, <span class="hljs-literal">NULL</span>)&#123;&#125;<br>    &#125;;<br><br>    <span class="hljs-function">string <span class="hljs-title">searhPrefix</span><span class="hljs-params">(Trie* root, <span class="hljs-type">const</span> string&amp; word)</span> </span>&#123;<br>        Trie* cur = root;<br>        string res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : word) &#123;<br>            <span class="hljs-keyword">if</span> (cur-&gt;children[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;isNotMatch&quot;</span>;<br>            &#125;<br>            res += c;<br>            cur = cur-&gt;children[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">if</span> (cur-&gt;isEnd == <span class="hljs-literal">true</span>) <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;isNotMatch&quot;</span>;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">replaceWords</span><span class="hljs-params">(vector&lt;string&gt;&amp; dictionary, string sentence)</span> </span>&#123;<br>        <span class="hljs-comment">// 构建前缀树Trie</span><br>        Trie* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>        <span class="hljs-keyword">for</span> (string&amp; str : dictionary) &#123;<br>            Trie* cur = root;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : str) &#123;<br>                <span class="hljs-keyword">if</span> (cur-&gt;children[c - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">NULL</span>) &#123;<br>                    cur-&gt;children[c - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>                &#125;<br>                cur = cur-&gt;children[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            &#125;<br>            cur-&gt;isEnd = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 分割字符串</span><br>        string word, res;<br>        <span class="hljs-function">stringstream <span class="hljs-title">input</span><span class="hljs-params">(sentence)</span></span>;<br>        <span class="hljs-keyword">while</span> (input &gt;&gt; word) &#123;<br>            <span class="hljs-comment">// 查找前缀prefix</span><br>            string prefix = <span class="hljs-built_in">searhPrefix</span>(root, word);<br>            <span class="hljs-keyword">if</span> (prefix != <span class="hljs-string">&quot;isNotMatch&quot;</span>) &#123;<br>                res += prefix;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res += word;<br>            &#125;<br>            res += <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        res.<span class="hljs-built_in">pop_back</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure></li><li><p><em>nullptr</em> 纯右值(need to study)</p></li><li><p>预编译-&gt;编译(目标文件obj,机器代码,可通过译码变为汇编指令)-&gt;链接</p></li><li><p>using Func &#x3D; int (*)(int,int) <em>函数指针</em></p></li><li><p>using 和 typedef 的区别在于typedef只能定义类型别，，using可以定义模板别名</p></li></ul><h1 id="3-2023-7-20"><a href="#3-2023-7-20" class="headerlink" title="3. 2023&#x2F;7&#x2F;20"></a>3. 2023&#x2F;7&#x2F;20</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ComplexType</span> &#123;<br>    T value;<br>    U otherValue;<br>&#125;;<br><br><span class="hljs-comment">// 使用 using 定义模板别名</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> MyAlias = ComplexType&lt;T, std::vector&lt;T&gt;&gt;;<br></code></pre></td></tr></table></figure><br><ul><li>using PI &#x3D; pair&lt;Treenode*,__uint128_t&gt;;</li><li><em>push_back() vs emplace_back()</em>  <blockquote><p>push_back时vector会新建一个数组,将新元素&amp;原vector中的元素<strong>深拷贝</strong>至新vector，原vector会被释放, 其中元素的析构函数也会被调用<br>注意: 这里只适用于没有创建固定大小空间的vector，若使用vector.reverse(N),提前创建好元素个数，可以提高存取速度<br>使用Reserve()而不是使用“vector<Point> vertices(3)”，因为下面的语法有时不起作用，因为类中没有定义默认构造函数。</p><p>使用emplace_back而不是使用参数化构造函数创建对象并将其分配到不同的内存中，然后将其传递给复制构造函数，复制构造函数会将其插入到向量中。该函数可以直接插入对象，无需调用复制构造函数。</p><p><em>如果构造函数接受多个参数，push_back 只接受该类型的一个对象obj，而emplace_back 接受该类型的构造函数的参数。</em></p></blockquote></li></ul><h1 id="4-2023-7-24"><a href="#4-2023-7-24" class="headerlink" title="4. 2023&#x2F;7&#x2F;24"></a>4. 2023&#x2F;7&#x2F;24</h1><ul><li><strong>vector empty是常数时间，empty()函数没有使用任何比较运算符，因此使用起来更方便,无论容器类型如何， empty() 函数都以恒定时间实现，而 size() 函数的某些实现需要 O(n) 时间复杂度，例如 list::size()。</strong></li><li><strong>size返回参数为size_t(unsigned int type)，要小心其在vecotr.size()-1上使用时出现小于0的情况出现段错误的情况</strong></li><li>Base(const Base&amp; temp_obj) &#x3D; <em>delete</em>;</li><li><strong>列表初始化(list initalize)</strong><ul><li><code>vector&lt;int&gt; vec&#123;1&#125;</code></li><li><code>vector&lt;pair&lt;int,int&gt;&gt; vec&#123;&#123;1,1&#125;&#125;</code><br></li><li><code>vector&lt;pair&lt;int,int&gt;&gt; vec&#123;make_pair(1,1)&#125;</code><br>not the vec{(1,1)},it’s evaluated as 1</li></ul></li><li><strong>逗号运算符，它是一种中缀运算符，用于对其左右两个表达式进行求值，并返回第二个表达式的值。</strong></li><li><strong>使用声明将基类的成员引入到派生类定义中，例如将基类的受保护成员公开为派生类的公共成员。在这种情况下，nested-name-specifier必须命名所定义的基类。如果名称是基类的重载成员函数的名称，则引入具有该名称的所有基类成员函数。如果派生类已具有具有相同名称、参数列表和限定条件的成员，则派生类成员将隐藏或覆盖（<em>不冲突</em>）从基类引入的成员。</strong></li><li><strong>protected关键字说明成员在派生类中是可见的</strong> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;B::f\n&quot;</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">char</span>)</span>        </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;B::g\n&quot;</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>         </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;B::h\n&quot;</span>; &#125;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> m; <span class="hljs-comment">// B::m is protected</span><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> value_type;<br>&#125;;<br> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">D</span> : B<br>&#123;<br>    <span class="hljs-keyword">using</span> B::m;          <span class="hljs-comment">// D::m is public</span><br>    <span class="hljs-keyword">using</span> B::value_type; <span class="hljs-comment">// D::value_type is public</span><br> <br>    <span class="hljs-keyword">using</span> B::f;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;D::f\n&quot;</span>; &#125; <span class="hljs-comment">// D::f(int) overrides B::f(int)</span><br> <br>    <span class="hljs-keyword">using</span> B::g;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;D::g\n&quot;</span>; &#125; <span class="hljs-comment">// both g(int) and g(char) are visible</span><br> <br>    <span class="hljs-keyword">using</span> B::h;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">h</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;D::h\n&quot;</span>; &#125; <span class="hljs-comment">// D::h(int) hides B::h(int)</span><br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    D d;<br>    B&amp; b = d;<br> <br><span class="hljs-comment">//  b.m = 2;  // Error: B::m is protected</span><br>    d.m = <span class="hljs-number">1</span>;  <span class="hljs-comment">// protected B::m is accessible as public D::m</span><br> <br>    b.<span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>);   <span class="hljs-comment">// calls derived f()</span><br>    d.<span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>);   <span class="hljs-comment">// calls derived f()</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;----------\n&quot;</span>;<br> <br>    d.<span class="hljs-built_in">g</span>(<span class="hljs-number">1</span>);   <span class="hljs-comment">// calls derived g(int)</span><br>    d.<span class="hljs-built_in">g</span>(<span class="hljs-string">&#x27;a&#x27;</span>); <span class="hljs-comment">// calls base g(char), exposed via using B::g;</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;----------\n&quot;</span>;<br> <br>    b.<span class="hljs-built_in">h</span>(<span class="hljs-number">1</span>);   <span class="hljs-comment">// calls base h()</span><br>    d.<span class="hljs-built_in">h</span>(<span class="hljs-number">1</span>);   <span class="hljs-comment">// calls derived h()</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>聚合初始化(aggregate initialization)</strong><br><ul><li>指定初始化器(designated initializers)  </li><li>four types of initializers：<ul><li>T object{d,s,i} brace elision is prohibited 直接列表初始化</li><li>T object&#x3D;{d,s,i} 复制初始化</li></ul></li></ul></li><li><cstdint>头文件规定了uint32_t &amp; so on</li></ul><h1 id="5-2023-7-25"><a href="#5-2023-7-25" class="headerlink" title="5. 2023&#x2F;7&#x2F;25"></a>5. 2023&#x2F;7&#x2F;25</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<span class="hljs-comment">//c++将printf和cout绑定到同一个输出流上，为了在输出时发生混乱，默认将cout的输出先放置在缓冲区，该语句可以打消输入输出的缓存，加快输入输出效率  </span><br>ios::<span class="hljs-built_in">tie</span>();<span class="hljs-comment">//This unties cin from cout. Tied streams ensure that one stream is flushed automatically before each I/O operation on the other stream.</span><br><span class="hljs-comment">//解耦输入输出流导致当程序等待用户输入时，输出信息并没有显示在屏幕，此时可以使用 std::flush或者std::endl来刷新缓冲区</span><br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><span class="hljs-comment">//返回值为指向在调用之前绑定的流对象的指针，或者在流未绑定的情况下为空指针。</span><br></code></pre></td></tr></table></figure><ul><li><a href="https://www.runoob.com/cplusplus/cpp-files-streams.html">c++文件与流</a></li><li>cin 与 cin.get()都会将分隔符留在输入缓冲区中</li><li><a href="https://en.cppreference.com/w/cpp/string/basic_string/getline">c++ getline</a><ul><li>getline分为两类:<table><thead><tr><th>std:getline  string流里的</th><th>std:basic_istream  isstream流里的，主要用来提取C string</th></tr></thead><tbody><tr><td>getline(cin,str,delim)</td><td>cin.getline(streamsize,delim)</td></tr><tr><td>存储的字符大于str.max_size()或者碰到分隔符会结束提取字符</td><td>存储的字符等于streamsize-1或者碰到分隔符会结束提取字符</td></tr><tr><td>分割符会被提取但不会被存储</td><td>分隔符会被提取同时被计数</td></tr></tbody></table></li></ul></li><li><em>memcpy</em> &amp; <em>memmove</em><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">memcpy</span>(array.<span class="hljs-built_in">data</span>(),str,bytessize) <span class="hljs-comment">//拷贝指定字节数至des</span><br><span class="hljs-built_in">memmove</span>(array.<span class="hljs-built_in">data</span>()/des,str/src,bytessize) <span class="hljs-comment">//当src+bytessize和des有重叠字节时用memmove </span><br></code></pre></td></tr></table></figure></li></ul><h1 id="6-2023-7-26"><a href="#6-2023-7-26" class="headerlink" title="6. 2023&#x2F;7&#x2F;26"></a>6. 2023&#x2F;7&#x2F;26</h1><ul><li><p>queue,stack等adapter列表初始化时不能直接使用brace,要先使用brace将其转化为底层容器，再用小括号将其转化为adapter<br><strong>queue<int> myqueue({1,2,3})</strong></p></li><li><p><em>同一行不能用逗号隔开两个不同类型变量的定义或声明</em></p></li><li><p><a href="https://www.stroustrup.com/bs_faq2.html#in-class">c++中类static member有关问题</a></p></li><li><p><strong>并查集的标准写法</strong></p><ul><li>私有成员成员vector也可以通过列表成员初始化进行初始化</li><li><strong>iota</strong>：对序列中的元素进行值递增操作 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UF</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; fa;<br>    vector&lt;<span class="hljs-type">int</span>&gt; sz;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span> comp_cnt;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UF</span>(<span class="hljs-type">int</span> _n): <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">comp_cnt</span>(_n), <span class="hljs-built_in">fa</span>(_n), <span class="hljs-built_in">sz</span>(_n, <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">iota</span>(fa.<span class="hljs-built_in">begin</span>(), fa.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findset</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> fa[x] == x ? x : fa[x] = <span class="hljs-built_in">findset</span>(fa[x]);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        x = <span class="hljs-built_in">findset</span>(x);<br>        y = <span class="hljs-built_in">findset</span>(y);<br>        <span class="hljs-keyword">if</span> (x == y) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sz[x] &lt; sz[y]) &#123;<br>            <span class="hljs-built_in">swap</span>(x, y);<br>        &#125;<br>        fa[y] = x;<br>        sz[x] += sz[y];<br>        --comp_cnt;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">connected</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        x = <span class="hljs-built_in">findset</span>(x);<br>        y = <span class="hljs-built_in">findset</span>(y);<br>        <span class="hljs-keyword">return</span> x == y;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>结构化绑定</p><ul><li>auto [x, y] &#x3D; q.front();&#x2F;&#x2F;无需使用q.front().first</li></ul></li><li><p>vector.erase(std::unique(vector.begin(), vector.end()),vector.end());</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>cpp related</category>
      
    </categories>
    
    
    <tags>
      
      <tag>encounter cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
